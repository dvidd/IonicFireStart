{"version":3,"file":"collection.js","sourceRoot":"","sources":["../../../../../src/firestore/collection/collection.ts"],"names":[],"mappings":"AACA,OAAO,oBAAoB,CAAC;AAG5B,OAAO,EAAE,iBAAiB,EAAE,MAAM,uBAAuB,CAAC;AAC1D,OAAO,uBAAuB,CAAC;AAC/B,OAAO,0BAA0B,CAAC;AAMlC,OAAO,EAAE,UAAU,EAAE,aAAa,EAAE,MAAM,WAAW,CAAC;AACtD,OAAO,EAAE,wBAAwB,EAAE,MAAM,sBAAsB,CAAC;AAEhE,MAAM,8BAA8B,MAAgD;IAClF,EAAE,CAAA,CAAC,CAAC,MAAM,IAAI,MAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QACnC,MAAM,GAAG,CAAC,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;KAC3C;IACD,MAAM,CAAC,MAAM,CAAC;CACf;AAyBD,MAAM;IAWJ,YACkB,GAA2C,EAC1C,KAA+B;QADhC,QAAG,GAAH,GAAG,CAAwC;QAC1C,UAAK,GAAL,KAAK,CAA0B;KAAK;IAQvD,YAAY,CAAC,MAAgD;QAC3D,EAAE,CAAA,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAClC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAC/B;QACD,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC;aAC1B,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aAC1E,MAAM,CAAC,OAAO,IAAK,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KAC3C;IAOD,UAAU,CAAC,MAAgD;QACzD,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK,CAAC,GAAG,OAAO,EAAE,GAAG,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;KACzF;IAOD,eAAe,CAAC,MAAgD;QAC9D,MAAM,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;QACrC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;KAC1C;IAKD,YAAY,CAAC,MAAgD;QAC3D,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC;aACjC,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAQ,CAAC,CAAC;KACnE;IASD,GAAG,CAAC,IAAO;QACT,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KAC3B;IAMD,GAAG,CAAI,IAAY;QACjB,MAAM,CAAC,IAAI,wBAAwB,CAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;KAC5D;CACF","sourcesContent":["import * as firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/filter';\n\nimport { Injectable } from '@angular/core';\nimport { FirebaseApp } from 'angularfire2';\n\nimport { QueryFn, AssociatedReference, DocumentChangeAction } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\n\nexport function validateEventsArray(events?: firebase.firestore.DocumentChangeType[]) {\n  if(!events || events!.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n * \n * This class creates a reference to a Firestore Collection. A reference and a query are provided in \n * in the constructor. The query can be the unqueried reference if no query is desired.The class \n * is generic which gives you type safety for data update methods and data streaming.\n * \n * This class uses Symbol.observable to transform into Observable using Observable.from().\n * \n * This class is rarely used directly and should be created from the AngularFirestore service.\n * \n * Example:\n * \n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n * \n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n * \n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T> {\n  /**\n   * The contstuctor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   * \n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details \n   * on this implication.\n   * @param ref \n   */  \n  constructor(\n    public readonly ref: firebase.firestore.CollectionReference,\n    private readonly query: firebase.firestore.Query) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events \n   */\n  stateChanges(events?: firebase.firestore.DocumentChangeType[]): Observable<DocumentChangeAction[]> {\n    if(!events || events.length === 0) {\n      return docChanges(this.query);\n    }\n    return docChanges(this.query)\n      .map(actions => actions.filter(change => events.indexOf(change.type) > -1))\n      .filter(changes =>  changes.length > 0);\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events \n   */\n  auditTrail(events?: firebase.firestore.DocumentChangeType[]): Observable<DocumentChangeAction[]> {\n    return this.stateChanges(events).scan((current, action) => [...current, ...action], []);\n  }\n  \n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events \n   */\n  snapshotChanges(events?: firebase.firestore.DocumentChangeType[]): Observable<DocumentChangeAction[]> {\n    events = validateEventsArray(events);\n    return sortedChanges(this.query, events);\n  }\n  \n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   */  \n  valueChanges(events?: firebase.firestore.DocumentChangeType[]): Observable<T[]> {\n    return fromCollectionRef(this.query)\n      .map(actions => actions.payload.docs.map(a => a.data()) as T[]);\n  }\n\n  /**\n   * Add data to a collection reference.\n   * \n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T) {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   * @param path \n   */\n  doc<T>(path: string) {\n    return new AngularFirestoreDocument<T>(this.ref.doc(path));\n  }\n}\n"]}