import { __extends, __awaiter, __generator, __assign } from 'tslib';
import { HostListener, Directive, ElementRef, Injectable, defineInjectable, Optional, inject, Component, ChangeDetectorRef, InjectionToken, NgZone, ApplicationRef, Injector, ViewContainerRef, ComponentFactoryResolver, Attribute, Output, EventEmitter, ViewChild, ContentChild, TemplateRef, ChangeDetectionStrategy, IterableDiffers, APP_INITIALIZER, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Location, LocationStrategy, CommonModule } from '@angular/common';
import { Router, NavigationStart, ChildrenOutletContexts, ActivatedRoute, PRIMARY_OUTLET, RouterLink } from '@angular/router';
import { Subject, fromEvent } from 'rxjs';
import { defineCustomElements } from '@ionic/core/loader';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValueAccessor = /** @class */ (function () {
    function ValueAccessor(el) {
        this.el = el;
        this.onChange = function () { };
        this.onTouched = function () { };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ValueAccessor.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.el.nativeElement.value = this.lastValue = value == null ? '' : value;
        setIonicClasses(this.el);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ValueAccessor.prototype.handleChangeEvent = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.lastValue) {
            this.lastValue = value;
            this.onChange(value);
        }
        setIonicClasses(this.el);
    };
    /**
     * @return {?}
     */
    ValueAccessor.prototype._handleBlurEvent = /**
     * @return {?}
     */
    function () {
        this.onTouched();
        setIonicClasses(this.el);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ValueAccessor.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ValueAccessor.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    ValueAccessor.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.el.nativeElement.disabled = isDisabled;
    };
    ValueAccessor.propDecorators = {
        _handleBlurEvent: [{ type: HostListener, args: ['ionBlur',] }]
    };
    return ValueAccessor;
}());
/**
 * @param {?} element
 * @return {?}
 */
function setIonicClasses(element) {
    requestAnimationFrame(function () {
        /** @type {?} */
        var classList = ((/** @type {?} */ (element.nativeElement))).classList;
        classList.remove('ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine');
        for (var i = 0; i < classList.length; i++) {
            /** @type {?} */
            var item = classList.item(i);
            if (item !== null && startsWith(item, 'ng-')) {
                classList.add("ion-" + item.substr(3));
            }
        }
    });
}
/**
 * @param {?} input
 * @param {?} search
 * @return {?}
 */
function startsWith(input, search) {
    return input.substr(0, search.length) === search;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BooleanValueAccessor = /** @class */ (function (_super) {
    __extends(BooleanValueAccessor, _super);
    function BooleanValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    BooleanValueAccessor.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.el.nativeElement.checked = this.lastValue = value == null ? false : value;
        setIonicClasses(this.el);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BooleanValueAccessor.prototype._handleIonChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.handleChangeEvent(value);
    };
    BooleanValueAccessor.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'ion-checkbox,ion-toggle',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: BooleanValueAccessor,
                            multi: true
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    BooleanValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    BooleanValueAccessor.propDecorators = {
        _handleIonChange: [{ type: HostListener, args: ['ionChange', ['$event.target.checked'],] }]
    };
    return BooleanValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NumericValueAccessor = /** @class */ (function (_super) {
    __extends(NumericValueAccessor, _super);
    function NumericValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    NumericValueAccessor.prototype._handleIonChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.handleChangeEvent(value);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NumericValueAccessor.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        _super.prototype.registerOnChange.call(this, function (value) {
            fn(value === '' ? null : parseFloat(value));
        });
    };
    NumericValueAccessor.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'ion-input[type=number]',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: NumericValueAccessor,
                            multi: true
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    NumericValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    NumericValueAccessor.propDecorators = {
        _handleIonChange: [{ type: HostListener, args: ['ionChange', ['$event.target.value'],] }]
    };
    return NumericValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RadioValueAccessor = /** @class */ (function (_super) {
    __extends(RadioValueAccessor, _super);
    function RadioValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    RadioValueAccessor.prototype._handleIonSelect = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.handleChangeEvent(value);
    };
    RadioValueAccessor.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'ion-radio',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: RadioValueAccessor,
                            multi: true
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    RadioValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    RadioValueAccessor.propDecorators = {
        _handleIonSelect: [{ type: HostListener, args: ['ionSelect', ['$event.target.checked'],] }]
    };
    return RadioValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SelectValueAccessor = /** @class */ (function (_super) {
    __extends(SelectValueAccessor, _super);
    function SelectValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    SelectValueAccessor.prototype._handleChangeEvent = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.handleChangeEvent(value);
    };
    SelectValueAccessor.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: SelectValueAccessor,
                            multi: true
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    SelectValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    SelectValueAccessor.propDecorators = {
        _handleChangeEvent: [{ type: HostListener, args: ['ionChange', ['$event.target.value'],] }]
    };
    return SelectValueAccessor;
}(ValueAccessor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TextValueAccessor = /** @class */ (function (_super) {
    __extends(TextValueAccessor, _super);
    function TextValueAccessor(el) {
        return _super.call(this, el) || this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    TextValueAccessor.prototype._handleInputEvent = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.handleChangeEvent(value);
    };
    TextValueAccessor.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line:directive-selector */
                    selector: 'ion-input:not([type=number]),ion-textarea,ion-searchbar',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: TextValueAccessor,
                            multi: true
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    TextValueAccessor.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    TextValueAccessor.propDecorators = {
        _handleInputEvent: [{ type: HostListener, args: ['ionChange', ['$event.target.value'],] }]
    };
    return TextValueAccessor;
}(ValueAccessor));

var PLATFORMS_MAP={ipad:isIpad,iphone:isIphone,ios:isIOS,android:isAndroid,phablet:isPhablet,tablet:isTablet,cordova:isCordova,capacitor:isCapacitorNative,electron:isElectron,pwa:isPWA,mobile:isMobile,desktop:isDesktop,hybrid:isHybrid};function getPlatforms(t){return setupPlatforms(t)}function isPlatform(t,i){return getPlatforms(t).includes(i)}function setupPlatforms(t){t.Ionic=t.Ionic||{};var i=t.Ionic.platforms;if(null==i){i=t.Ionic.platforms=detectPlatforms(t);var n=t.document.documentElement.classList;i.forEach(function(t){return n.add("plt-"+t)});}return i}function detectPlatforms(t){return Object.keys(PLATFORMS_MAP).filter(function(i){return PLATFORMS_MAP[i](t)})}function isIpad(t){return testUserAgent(t,/iPad/i)}function isIphone(t){return testUserAgent(t,/iPhone/i)}function isIOS(t){return testUserAgent(t,/iPad|iPhone|iPod/i)}function isAndroid(t){return testUserAgent(t,/android|sink/i)}function isPhablet(t){var i=t.innerWidth,n=t.innerHeight,e=Math.min(i,n),r=Math.max(i,n);return e>390&&e<520&&r>620&&r<800}function isTablet(t){var i=t.innerWidth,n=t.innerHeight,e=Math.min(i,n),r=Math.max(i,n);return e>460&&e<820&&r>780&&r<1400}function isMobile(t){return matchMedia(t,"(any-pointer:coarse)")}function isDesktop(t){return !isMobile(t)}function isHybrid(t){return isCordova(t)||isCapacitorNative(t)}function isCordova(t){return !!(t.cordova||t.phonegap||t.PhoneGap)}function isCapacitorNative(t){var i=t.Capacitor;return !(!i||!i.isNative)}function isElectron(t){return testUserAgent(t,/electron/)}function isPWA(t){return t.matchMedia("(display-mode: standalone)").matches}function testUserAgent(t,i){return i.test(t.navigator.userAgent)}function matchMedia(t,i){return t.matchMedia(i).matches}

var LIFECYCLE_WILL_ENTER="ionViewWillEnter",LIFECYCLE_DID_ENTER="ionViewDidEnter",LIFECYCLE_WILL_LEAVE="ionViewWillLeave",LIFECYCLE_DID_LEAVE="ionViewDidLeave",LIFECYCLE_WILL_UNLOAD="ionViewWillUnload";

// Ionic: ES Module

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Platform = /** @class */ (function () {
    function Platform() {
        /**
         * @hidden
         */
        this.backButton = (/** @type {?} */ (new Subject()));
        /**
         * The pause event emits when the native platform puts the application
         * into the background, typically when the user switches to a different
         * application. This event would emit when a Cordova app is put into
         * the background, however, it would not fire on a standard web browser.
         */
        this.pause = new Subject();
        /**
         * The resume event emits when the native platform pulls the application
         * out from the background. This event would emit when a Cordova app comes
         * out from the background, however, it would not fire on a standard web browser.
         */
        this.resume = new Subject();
        /**
         * The resize event emits when the browser window has changed dimensions. This
         * could be from a browser window being physically resized, or from a device
         * changing orientation.
         */
        this.resize = new Subject();
        this.backButton.subscribeWithPriority = function (priority, callback) {
            return this.subscribe(function (ev) {
                ev.register(priority, callback);
            });
        };
        proxyEvent(this.pause, document, 'pause');
        proxyEvent(this.resume, document, 'resume');
        proxyEvent(this.backButton, document, 'ionBackButton');
        proxyEvent(this.resize, window, 'resize');
        /** @type {?} */
        var readyResolve;
        this._readyPromise = new Promise(function (res) { readyResolve = res; });
        if (((/** @type {?} */ (window)))['cordova']) {
            document.addEventListener('deviceready', function () {
                readyResolve('cordova');
            }, { once: true });
        }
        else {
            (/** @type {?} */ (readyResolve))('dom');
        }
    }
    /**
     * @returns returns true/false based on platform.
     * @description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.   |
     * | mobile          | on a mobile device.                |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     */
    /**
     * \@description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.   |
     * | mobile          | on a mobile device.                |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     * @param {?} platformName
     * @return {?} returns true/false based on platform.
     */
    Platform.prototype.is = /**
     * \@description
     * Depending on the platform the user is on, `is(platformName)` will
     * return `true` or `false`. Note that the same app can return `true`
     * for more than one platform name. For example, an app running from
     * an iPad would return `true` for the platform names: `mobile`,
     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
     * from Cordova then `cordova` would be true, and if it was running
     * from a web browser on the iPad then `mobileweb` would be `true`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     if (this.platform.is('ios')) {
     *       // This will only print when on iOS
     *       console.log('I am an iOS device!');
     *     }
     *   }
     * }
     * ```
     *
     * | Platform Name   | Description                        |
     * |-----------------|------------------------------------|
     * | android         | on a device running Android.       |
     * | cordova         | on a device running Cordova.       |
     * | ios             | on a device running iOS.           |
     * | ipad            | on an iPad device.                 |
     * | iphone          | on an iPhone device.               |
     * | phablet         | on a phablet device.               |
     * | tablet          | on a tablet device.                |
     * | electron        | in Electron on a desktop device.   |
     * | pwa             | as a PWA app.   |
     * | mobile          | on a mobile device.                |
     * | desktop         | on a desktop device.               |
     * | hybrid          | is a cordova or capacitor app.     |
     *
     * @param {?} platformName
     * @return {?} returns true/false based on platform.
     */
    function (platformName) {
        return isPlatform(window, platformName);
    };
    /**
     * @returns the array of platforms
     * @description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * @Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     */
    /**
     * \@description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     * @return {?} the array of platforms
     */
    Platform.prototype.platforms = /**
     * \@description
     * Depending on what device you are on, `platforms` can return multiple values.
     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
     * it would return `mobile`, `ios`, and `iphone`.
     *
     * ```
     * import { Platform } from 'ionic-angular';
     *
     * \@Component({...})
     * export MyPage {
     *   constructor(public platform: Platform) {
     *     // This will print an array of the current platforms
     *     console.log(this.platform.platforms());
     *   }
     * }
     * ```
     * @return {?} the array of platforms
     */
    function () {
        return getPlatforms(window);
    };
    /**
     * @return {?}
     */
    Platform.prototype.ready = /**
     * @return {?}
     */
    function () {
        return this._readyPromise;
    };
    Object.defineProperty(Platform.prototype, "isRTL", {
        get: /**
         * @return {?}
         */
        function () {
            return document.dir === 'rtl';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the query string parameter
     */
    /**
     * Get the query string parameter
     * @param {?} key
     * @return {?}
     */
    Platform.prototype.getQueryParam = /**
     * Get the query string parameter
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return readQueryParam(window.location.href, key);
    };
    /**
     * @return {?}
     */
    Platform.prototype.isLandscape = /**
     * @return {?}
     */
    function () {
        return !this.isPortrait();
    };
    /**
     * @return {?}
     */
    Platform.prototype.isPortrait = /**
     * @return {?}
     */
    function () {
        return window.matchMedia('(orientation: portrait)').matches;
    };
    /**
     * @param {?} expression
     * @return {?}
     */
    Platform.prototype.testUserAgent = /**
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        return navigator.userAgent.indexOf(expression) >= 0;
    };
    /**
     * @return {?}
     */
    Platform.prototype.url = /**
     * @return {?}
     */
    function () {
        return window.location.href;
    };
    /**
     * @return {?}
     */
    Platform.prototype.width = /**
     * @return {?}
     */
    function () {
        return window.innerWidth;
    };
    /**
     * @return {?}
     */
    Platform.prototype.height = /**
     * @return {?}
     */
    function () {
        return window.innerHeight;
    };
    Platform.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    Platform.ctorParameters = function () { return []; };
    /** @nocollapse */ Platform.ngInjectableDef = defineInjectable({ factory: function Platform_Factory() { return new Platform(); }, token: Platform, providedIn: "root" });
    return Platform;
}());
/**
 * @param {?} url
 * @param {?} key
 * @return {?}
 */
function readQueryParam(url, key) {
    key = key.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    /** @type {?} */
    var regex = new RegExp('[\\?&]' + key + '=([^&#]*)');
    /** @type {?} */
    var results = regex.exec(url);
    return results ? decodeURIComponent(results[1].replace(/\+/g, ' ')) : null;
}
/**
 * @template T
 * @param {?} emitter
 * @param {?} el
 * @param {?} eventName
 * @return {?}
 */
function proxyEvent(emitter, el, eventName) {
    el.addEventListener(eventName, function (ev) {
        // ?? cordova might emit "null" events
        emitter.next(ev != null ? (/** @type {?} */ (((/** @type {?} */ (ev))).detail)) : undefined);
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavController = /** @class */ (function () {
    function NavController(platform, location, router) {
        var _this = this;
        this.location = location;
        this.router = router;
        this.direction = DEFAULT_DIRECTION;
        this.animated = DEFAULT_ANIMATED;
        this.guessDirection = 'forward';
        this.lastNavId = -1;
        // Subscribe to router events to detect direction
        if (router) {
            router.events.subscribe(function (ev) {
                if (ev instanceof NavigationStart) {
                    /** @type {?} */
                    var id = (ev.restoredState) ? ev.restoredState.navigationId : ev.id;
                    _this.guessDirection = id < _this.lastNavId ? 'back' : 'forward';
                    _this.guessAnimation = !ev.restoredState ? _this.guessDirection : undefined;
                    _this.lastNavId = _this.guessDirection === 'forward' ? ev.id : id;
                }
            });
        }
        // Subscribe to backButton events
        platform.backButton.subscribeWithPriority(0, function () { return _this.goBack(); });
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.navigateForward = /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        this.setDirection('forward', options.animated, options.animationDirection);
        this.navigate(url, options);
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.navigateBack = /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        this.setDirection('back', options.animated, options.animationDirection);
        this.navigate(url, options);
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.navigateRoot = /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        if (options === void 0) { options = {}; }
        this.setDirection('root', options.animated, options.animationDirection);
        this.navigate(url, options);
    };
    /**
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    NavController.prototype.navigate = /**
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    function (url, options) {
        if (Array.isArray(url)) {
            return (/** @type {?} */ (this.router)).navigate(url, options);
        }
        else {
            return (/** @type {?} */ (this.router)).navigateByUrl(url, options);
        }
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    NavController.prototype.goBack = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        if (options === void 0) { options = { animated: true, animationDirection: 'back' }; }
        this.setDirection('back', options.animated, options.animationDirection);
        return this.location.back();
    };
    /**
     * @param {?} direction
     * @param {?=} animated
     * @param {?=} animationDirection
     * @return {?}
     */
    NavController.prototype.setDirection = /**
     * @param {?} direction
     * @param {?=} animated
     * @param {?=} animationDirection
     * @return {?}
     */
    function (direction, animated, animationDirection) {
        this.direction = direction;
        this.animated = getAnimation(direction, animated, animationDirection);
    };
    /**
     * @return {?}
     */
    NavController.prototype.consumeTransition = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var direction = 'root';
        /** @type {?} */
        var animation;
        if (this.direction === 'auto') {
            direction = this.guessDirection;
            animation = this.guessAnimation;
        }
        else {
            animation = this.animated;
            direction = this.direction;
        }
        this.direction = DEFAULT_DIRECTION;
        this.animated = DEFAULT_ANIMATED;
        return {
            direction: direction,
            animation: animation
        };
    };
    NavController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    NavController.ctorParameters = function () { return [
        { type: Platform },
        { type: Location },
        { type: Router, decorators: [{ type: Optional }] }
    ]; };
    /** @nocollapse */ NavController.ngInjectableDef = defineInjectable({ factory: function NavController_Factory() { return new NavController(inject(Platform), inject(Location), inject(Router, 8)); }, token: NavController, providedIn: "root" });
    return NavController;
}());
/**
 * @param {?} direction
 * @param {?} animated
 * @param {?} animationDirection
 * @return {?}
 */
function getAnimation(direction, animated, animationDirection) {
    if (animated === false) {
        return undefined;
    }
    if (animationDirection !== undefined) {
        return animationDirection;
    }
    if (direction === 'forward' || direction === 'back') {
        return direction;
    }
    return undefined;
}
/** @type {?} */
var DEFAULT_DIRECTION = 'auto';
/** @type {?} */
var DEFAULT_ANIMATED = undefined;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} Cmp
 * @param {?} inputs
 * @return {?}
 */
function proxyInputs(Cmp, inputs) {
    /** @type {?} */
    var Prototype = Cmp.prototype;
    inputs.forEach(function (item) {
        Object.defineProperty(Prototype, item, {
            get: /**
             * @return {?}
             */
            function () { return this.el[item]; },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) { this.el[item] = val; },
        });
    });
}
/**
 * @param {?} Cmp
 * @param {?} methods
 * @return {?}
 */
function proxyMethods(Cmp, methods) {
    /** @type {?} */
    var Prototype = Cmp.prototype;
    methods.forEach(function (methodName) {
        Prototype[methodName] = function () {
            /** @type {?} */
            var args = arguments;
            return this.el.componentOnReady().then(function (el) { return el[methodName].apply(el, args); });
        };
    });
}
/**
 * @param {?} instance
 * @param {?} el
 * @param {?} events
 * @return {?}
 */
function proxyOutputs(instance, el, events) {
    events.forEach(function (eventName) { return instance[eventName] = fromEvent(el, eventName); });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonApp = /** @class */ (function () {
    function IonApp(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonApp.decorators = [
        { type: Component, args: [{ selector: 'ion-app', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonApp.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonApp;
}());
var IonAvatar = /** @class */ (function () {
    function IonAvatar(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonAvatar.decorators = [
        { type: Component, args: [{ selector: 'ion-avatar', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonAvatar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonAvatar;
}());
var IonBackButton = /** @class */ (function () {
    function IonBackButton(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonBackButton.decorators = [
        { type: Component, args: [{ selector: 'ion-back-button', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'defaultHref', 'icon', 'text'] },] },
    ];
    /** @nocollapse */
    IonBackButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonBackButton;
}());
proxyInputs(IonBackButton, ['color', 'mode', 'defaultHref', 'icon', 'text']);
var IonBackdrop = /** @class */ (function () {
    function IonBackdrop(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionBackdropTap']);
    }
    IonBackdrop.decorators = [
        { type: Component, args: [{ selector: 'ion-backdrop', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['visible', 'tappable', 'stopPropagation'] },] },
    ];
    /** @nocollapse */
    IonBackdrop.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonBackdrop;
}());
proxyInputs(IonBackdrop, ['visible', 'tappable', 'stopPropagation']);
var IonBadge = /** @class */ (function () {
    function IonBadge(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonBadge.decorators = [
        { type: Component, args: [{ selector: 'ion-badge', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonBadge.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonBadge;
}());
proxyInputs(IonBadge, ['color', 'mode']);
var IonButton = /** @class */ (function () {
    function IonButton(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
    }
    IonButton.decorators = [
        { type: Component, args: [{ selector: 'ion-button', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'buttonType', 'disabled', 'expand', 'fill', 'routerDirection', 'href', 'shape', 'size', 'strong', 'type'] },] },
    ];
    /** @nocollapse */
    IonButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonButton;
}());
proxyInputs(IonButton, ['color', 'mode', 'buttonType', 'disabled', 'expand', 'fill', 'routerDirection', 'href', 'shape', 'size', 'strong', 'type']);
var IonButtons = /** @class */ (function () {
    function IonButtons(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonButtons.decorators = [
        { type: Component, args: [{ selector: 'ion-buttons', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonButtons.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonButtons;
}());
var IonCard = /** @class */ (function () {
    function IonCard(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonCard.decorators = [
        { type: Component, args: [{ selector: 'ion-card', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonCard.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCard;
}());
proxyInputs(IonCard, ['color', 'mode']);
var IonCardContent = /** @class */ (function () {
    function IonCardContent(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonCardContent.decorators = [
        { type: Component, args: [{ selector: 'ion-card-content', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode'] },] },
    ];
    /** @nocollapse */
    IonCardContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCardContent;
}());
proxyInputs(IonCardContent, ['mode']);
var IonCardHeader = /** @class */ (function () {
    function IonCardHeader(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonCardHeader.decorators = [
        { type: Component, args: [{ selector: 'ion-card-header', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'translucent'] },] },
    ];
    /** @nocollapse */
    IonCardHeader.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCardHeader;
}());
proxyInputs(IonCardHeader, ['color', 'mode', 'translucent']);
var IonCardSubtitle = /** @class */ (function () {
    function IonCardSubtitle(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonCardSubtitle.decorators = [
        { type: Component, args: [{ selector: 'ion-card-subtitle', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonCardSubtitle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCardSubtitle;
}());
proxyInputs(IonCardSubtitle, ['color', 'mode']);
var IonCardTitle = /** @class */ (function () {
    function IonCardTitle(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonCardTitle.decorators = [
        { type: Component, args: [{ selector: 'ion-card-title', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonCardTitle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCardTitle;
}());
proxyInputs(IonCardTitle, ['color', 'mode']);
var IonCheckbox = /** @class */ (function () {
    function IonCheckbox(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
    }
    IonCheckbox.decorators = [
        { type: Component, args: [{ selector: 'ion-checkbox', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'name', 'checked', 'disabled', 'value'] },] },
    ];
    /** @nocollapse */
    IonCheckbox.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCheckbox;
}());
proxyInputs(IonCheckbox, ['color', 'mode', 'name', 'checked', 'disabled', 'value']);
var IonChip = /** @class */ (function () {
    function IonChip(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonChip.decorators = [
        { type: Component, args: [{ selector: 'ion-chip', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'outline'] },] },
    ];
    /** @nocollapse */
    IonChip.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonChip;
}());
proxyInputs(IonChip, ['color', 'mode', 'outline']);
var IonCol = /** @class */ (function () {
    function IonCol(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonCol.decorators = [
        { type: Component, args: [{ selector: 'ion-col', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['offset', 'offsetXs', 'offsetSm', 'offsetMd', 'offsetLg', 'offsetXl', 'pull', 'pullXs', 'pullSm', 'pullMd', 'pullLg', 'pullXl', 'push', 'pushXs', 'pushSm', 'pushMd', 'pushLg', 'pushXl', 'size', 'sizeXs', 'sizeSm', 'sizeMd', 'sizeLg', 'sizeXl'] },] },
    ];
    /** @nocollapse */
    IonCol.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonCol;
}());
proxyInputs(IonCol, ['offset', 'offsetXs', 'offsetSm', 'offsetMd', 'offsetLg', 'offsetXl', 'pull', 'pullXs', 'pullSm', 'pullMd', 'pullLg', 'pullXl', 'push', 'pushXs', 'pushSm', 'pushMd', 'pushLg', 'pushXl', 'size', 'sizeXs', 'sizeSm', 'sizeMd', 'sizeLg', 'sizeXl']);
var IonContent = /** @class */ (function () {
    function IonContent(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionScrollStart', 'ionScroll', 'ionScrollEnd']);
    }
    IonContent.decorators = [
        { type: Component, args: [{ selector: 'ion-content', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'fullscreen', 'forceOverscroll', 'scrollX', 'scrollY', 'scrollEvents'] },] },
    ];
    /** @nocollapse */
    IonContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonContent;
}());
proxyMethods(IonContent, ['getScrollElement', 'scrollToTop', 'scrollToBottom', 'scrollByPoint', 'scrollToPoint']);
proxyInputs(IonContent, ['color', 'fullscreen', 'forceOverscroll', 'scrollX', 'scrollY', 'scrollEvents']);
var IonDatetime = /** @class */ (function () {
    function IonDatetime(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionCancel', 'ionChange', 'ionFocus', 'ionBlur']);
    }
    IonDatetime.decorators = [
        { type: Component, args: [{ selector: 'ion-datetime', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'name', 'disabled', 'min', 'max', 'displayFormat', 'pickerFormat', 'cancelText', 'doneText', 'yearValues', 'monthValues', 'dayValues', 'hourValues', 'minuteValues', 'monthNames', 'monthShortNames', 'dayNames', 'dayShortNames', 'pickerOptions', 'placeholder', 'value'] },] },
    ];
    /** @nocollapse */
    IonDatetime.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonDatetime;
}());
proxyMethods(IonDatetime, ['open']);
proxyInputs(IonDatetime, ['mode', 'name', 'disabled', 'min', 'max', 'displayFormat', 'pickerFormat', 'cancelText', 'doneText', 'yearValues', 'monthValues', 'dayValues', 'hourValues', 'minuteValues', 'monthNames', 'monthShortNames', 'dayNames', 'dayShortNames', 'pickerOptions', 'placeholder', 'value']);
var IonFab = /** @class */ (function () {
    function IonFab(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonFab.decorators = [
        { type: Component, args: [{ selector: 'ion-fab', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['horizontal', 'vertical', 'edge', 'activated'] },] },
    ];
    /** @nocollapse */
    IonFab.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonFab;
}());
proxyMethods(IonFab, ['close']);
proxyInputs(IonFab, ['horizontal', 'vertical', 'edge', 'activated']);
var IonFabButton = /** @class */ (function () {
    function IonFabButton(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionFocus', 'ionBlur']);
    }
    IonFabButton.decorators = [
        { type: Component, args: [{ selector: 'ion-fab-button', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'color', 'activated', 'disabled', 'href', 'routerDirection', 'show', 'translucent', 'type', 'size'] },] },
    ];
    /** @nocollapse */
    IonFabButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonFabButton;
}());
proxyInputs(IonFabButton, ['mode', 'color', 'activated', 'disabled', 'href', 'routerDirection', 'show', 'translucent', 'type', 'size']);
var IonFabList = /** @class */ (function () {
    function IonFabList(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonFabList.decorators = [
        { type: Component, args: [{ selector: 'ion-fab-list', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['activated', 'side'] },] },
    ];
    /** @nocollapse */
    IonFabList.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonFabList;
}());
proxyInputs(IonFabList, ['activated', 'side']);
var IonFooter = /** @class */ (function () {
    function IonFooter(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonFooter.decorators = [
        { type: Component, args: [{ selector: 'ion-footer', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'translucent'] },] },
    ];
    /** @nocollapse */
    IonFooter.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonFooter;
}());
proxyInputs(IonFooter, ['mode', 'translucent']);
var IonGrid = /** @class */ (function () {
    function IonGrid(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonGrid.decorators = [
        { type: Component, args: [{ selector: 'ion-grid', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['fixed'] },] },
    ];
    /** @nocollapse */
    IonGrid.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonGrid;
}());
proxyInputs(IonGrid, ['fixed']);
var IonHeader = /** @class */ (function () {
    function IonHeader(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonHeader.decorators = [
        { type: Component, args: [{ selector: 'ion-header', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'translucent'] },] },
    ];
    /** @nocollapse */
    IonHeader.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonHeader;
}());
proxyInputs(IonHeader, ['mode', 'translucent']);
var IonIcon = /** @class */ (function () {
    function IonIcon(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonIcon.decorators = [
        { type: Component, args: [{ selector: 'ion-icon', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['ariaLabel', 'color', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src'] },] },
    ];
    /** @nocollapse */
    IonIcon.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonIcon;
}());
proxyInputs(IonIcon, ['ariaLabel', 'color', 'icon', 'ios', 'lazy', 'md', 'mode', 'name', 'size', 'src']);
var IonImg = /** @class */ (function () {
    function IonImg(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionImgDidLoad']);
    }
    IonImg.decorators = [
        { type: Component, args: [{ selector: 'ion-img', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['alt', 'src'] },] },
    ];
    /** @nocollapse */
    IonImg.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonImg;
}());
proxyInputs(IonImg, ['alt', 'src']);
var IonInfiniteScroll = /** @class */ (function () {
    function IonInfiniteScroll(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInfinite']);
    }
    IonInfiniteScroll.decorators = [
        { type: Component, args: [{ selector: 'ion-infinite-scroll', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['threshold', 'disabled', 'position'] },] },
    ];
    /** @nocollapse */
    IonInfiniteScroll.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonInfiniteScroll;
}());
proxyMethods(IonInfiniteScroll, ['complete']);
proxyInputs(IonInfiniteScroll, ['threshold', 'disabled', 'position']);
var IonInfiniteScrollContent = /** @class */ (function () {
    function IonInfiniteScrollContent(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonInfiniteScrollContent.decorators = [
        { type: Component, args: [{ selector: 'ion-infinite-scroll-content', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['loadingSpinner', 'loadingText'] },] },
    ];
    /** @nocollapse */
    IonInfiniteScrollContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonInfiniteScrollContent;
}());
proxyInputs(IonInfiniteScrollContent, ['loadingSpinner', 'loadingText']);
var IonInput = /** @class */ (function () {
    function IonInput(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionBlur', 'ionFocus']);
    }
    IonInput.decorators = [
        { type: Component, args: [{ selector: 'ion-input', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'spellcheck', 'step', 'size', 'type', 'value'] },] },
    ];
    /** @nocollapse */
    IonInput.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonInput;
}());
proxyMethods(IonInput, ['setFocus']);
proxyInputs(IonInput, ['color', 'mode', 'accept', 'autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'clearInput', 'clearOnEdit', 'debounce', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'spellcheck', 'step', 'size', 'type', 'value']);
var IonItem = /** @class */ (function () {
    function IonItem(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonItem.decorators = [
        { type: Component, args: [{ selector: 'ion-item', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'button', 'detail', 'detailIcon', 'disabled', 'href', 'lines', 'routerDirection', 'type'] },] },
    ];
    /** @nocollapse */
    IonItem.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonItem;
}());
proxyInputs(IonItem, ['color', 'mode', 'button', 'detail', 'detailIcon', 'disabled', 'href', 'lines', 'routerDirection', 'type']);
var IonItemDivider = /** @class */ (function () {
    function IonItemDivider(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonItemDivider.decorators = [
        { type: Component, args: [{ selector: 'ion-item-divider', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'sticky'] },] },
    ];
    /** @nocollapse */
    IonItemDivider.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonItemDivider;
}());
proxyInputs(IonItemDivider, ['color', 'mode', 'sticky']);
var IonItemGroup = /** @class */ (function () {
    function IonItemGroup(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonItemGroup.decorators = [
        { type: Component, args: [{ selector: 'ion-item-group', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonItemGroup.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonItemGroup;
}());
var IonItemOption = /** @class */ (function () {
    function IonItemOption(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonItemOption.decorators = [
        { type: Component, args: [{ selector: 'ion-item-option', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'disabled', 'expandable', 'href'] },] },
    ];
    /** @nocollapse */
    IonItemOption.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonItemOption;
}());
proxyInputs(IonItemOption, ['color', 'mode', 'disabled', 'expandable', 'href']);
var IonItemOptions = /** @class */ (function () {
    function IonItemOptions(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSwipe']);
    }
    IonItemOptions.decorators = [
        { type: Component, args: [{ selector: 'ion-item-options', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['side'] },] },
    ];
    /** @nocollapse */
    IonItemOptions.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonItemOptions;
}());
proxyInputs(IonItemOptions, ['side']);
var IonItemSliding = /** @class */ (function () {
    function IonItemSliding(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionDrag']);
    }
    IonItemSliding.decorators = [
        { type: Component, args: [{ selector: 'ion-item-sliding', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['disabled'] },] },
    ];
    /** @nocollapse */
    IonItemSliding.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonItemSliding;
}());
proxyMethods(IonItemSliding, ['getOpenAmount', 'getSlidingRatio', 'close', 'closeOpened']);
proxyInputs(IonItemSliding, ['disabled']);
var IonLabel = /** @class */ (function () {
    function IonLabel(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonLabel.decorators = [
        { type: Component, args: [{ selector: 'ion-label', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'position'] },] },
    ];
    /** @nocollapse */
    IonLabel.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonLabel;
}());
proxyInputs(IonLabel, ['color', 'mode', 'position']);
var IonList = /** @class */ (function () {
    function IonList(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonList.decorators = [
        { type: Component, args: [{ selector: 'ion-list', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'lines', 'inset'] },] },
    ];
    /** @nocollapse */
    IonList.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonList;
}());
proxyMethods(IonList, ['closeSlidingItems']);
proxyInputs(IonList, ['mode', 'lines', 'inset']);
var IonListHeader = /** @class */ (function () {
    function IonListHeader(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonListHeader.decorators = [
        { type: Component, args: [{ selector: 'ion-list-header', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'color'] },] },
    ];
    /** @nocollapse */
    IonListHeader.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonListHeader;
}());
proxyInputs(IonListHeader, ['mode', 'color']);
var IonMenu = /** @class */ (function () {
    function IonMenu(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionWillOpen', 'ionWillClose', 'ionDidOpen', 'ionDidClose']);
    }
    IonMenu.decorators = [
        { type: Component, args: [{ selector: 'ion-menu', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['contentId', 'menuId', 'type', 'disabled', 'side', 'swipeGesture', 'maxEdgeStart'] },] },
    ];
    /** @nocollapse */
    IonMenu.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonMenu;
}());
proxyMethods(IonMenu, ['isOpen', 'isActive', 'open', 'close', 'toggle', 'setOpen']);
proxyInputs(IonMenu, ['contentId', 'menuId', 'type', 'disabled', 'side', 'swipeGesture', 'maxEdgeStart']);
var IonMenuButton = /** @class */ (function () {
    function IonMenuButton(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonMenuButton.decorators = [
        { type: Component, args: [{ selector: 'ion-menu-button', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'menu', 'autoHide'] },] },
    ];
    /** @nocollapse */
    IonMenuButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonMenuButton;
}());
proxyInputs(IonMenuButton, ['color', 'mode', 'menu', 'autoHide']);
var IonMenuToggle = /** @class */ (function () {
    function IonMenuToggle(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonMenuToggle.decorators = [
        { type: Component, args: [{ selector: 'ion-menu-toggle', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['menu', 'autoHide'] },] },
    ];
    /** @nocollapse */
    IonMenuToggle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonMenuToggle;
}());
proxyInputs(IonMenuToggle, ['menu', 'autoHide']);
var IonNav = /** @class */ (function () {
    function IonNav(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionNavWillLoad', 'ionNavWillChange', 'ionNavDidChange']);
    }
    IonNav.decorators = [
        { type: Component, args: [{ selector: 'ion-nav', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['swipeGesture', 'animated', 'animation', 'rootParams', 'root'] },] },
    ];
    /** @nocollapse */
    IonNav.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonNav;
}());
proxyMethods(IonNav, ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']);
proxyInputs(IonNav, ['swipeGesture', 'animated', 'animation', 'rootParams', 'root']);
var IonNavPop = /** @class */ (function () {
    function IonNavPop(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonNavPop.decorators = [
        { type: Component, args: [{ selector: 'ion-nav-pop', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonNavPop.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonNavPop;
}());
var IonNavPush = /** @class */ (function () {
    function IonNavPush(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonNavPush.decorators = [
        { type: Component, args: [{ selector: 'ion-nav-push', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps'] },] },
    ];
    /** @nocollapse */
    IonNavPush.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonNavPush;
}());
proxyInputs(IonNavPush, ['component', 'componentProps']);
var IonNavSetRoot = /** @class */ (function () {
    function IonNavSetRoot(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonNavSetRoot.decorators = [
        { type: Component, args: [{ selector: 'ion-nav-set-root', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['component', 'componentProps'] },] },
    ];
    /** @nocollapse */
    IonNavSetRoot.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonNavSetRoot;
}());
proxyInputs(IonNavSetRoot, ['component', 'componentProps']);
var IonNote = /** @class */ (function () {
    function IonNote(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonNote.decorators = [
        { type: Component, args: [{ selector: 'ion-note', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonNote.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonNote;
}());
proxyInputs(IonNote, ['color', 'mode']);
var IonProgressBar = /** @class */ (function () {
    function IonProgressBar(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonProgressBar.decorators = [
        { type: Component, args: [{ selector: 'ion-progress-bar', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'type', 'reversed', 'value', 'buffer', 'color'] },] },
    ];
    /** @nocollapse */
    IonProgressBar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonProgressBar;
}());
proxyInputs(IonProgressBar, ['mode', 'type', 'reversed', 'value', 'buffer', 'color']);
var IonRadio = /** @class */ (function () {
    function IonRadio(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSelect', 'ionFocus', 'ionBlur']);
    }
    IonRadio.decorators = [
        { type: Component, args: [{ selector: 'ion-radio', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'name', 'disabled', 'checked', 'value'] },] },
    ];
    /** @nocollapse */
    IonRadio.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRadio;
}());
proxyInputs(IonRadio, ['color', 'mode', 'name', 'disabled', 'checked', 'value']);
var IonRadioGroup = /** @class */ (function () {
    function IonRadioGroup(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange']);
    }
    IonRadioGroup.decorators = [
        { type: Component, args: [{ selector: 'ion-radio-group', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['allowEmptySelection', 'name', 'value'] },] },
    ];
    /** @nocollapse */
    IonRadioGroup.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRadioGroup;
}());
proxyInputs(IonRadioGroup, ['allowEmptySelection', 'name', 'value']);
var IonRange = /** @class */ (function () {
    function IonRange(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
    }
    IonRange.decorators = [
        { type: Component, args: [{ selector: 'ion-range', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'debounce', 'name', 'dualKnobs', 'min', 'max', 'pin', 'snaps', 'step', 'disabled', 'value'] },] },
    ];
    /** @nocollapse */
    IonRange.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRange;
}());
proxyInputs(IonRange, ['color', 'mode', 'debounce', 'name', 'dualKnobs', 'min', 'max', 'pin', 'snaps', 'step', 'disabled', 'value']);
var IonRefresher = /** @class */ (function () {
    function IonRefresher(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionRefresh', 'ionPull', 'ionStart']);
    }
    IonRefresher.decorators = [
        { type: Component, args: [{ selector: 'ion-refresher', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['pullMin', 'pullMax', 'closeDuration', 'snapbackDuration', 'disabled'] },] },
    ];
    /** @nocollapse */
    IonRefresher.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRefresher;
}());
proxyMethods(IonRefresher, ['complete', 'cancel', 'getProgress']);
proxyInputs(IonRefresher, ['pullMin', 'pullMax', 'closeDuration', 'snapbackDuration', 'disabled']);
var IonRefresherContent = /** @class */ (function () {
    function IonRefresherContent(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonRefresherContent.decorators = [
        { type: Component, args: [{ selector: 'ion-refresher-content', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText'] },] },
    ];
    /** @nocollapse */
    IonRefresherContent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRefresherContent;
}());
proxyInputs(IonRefresherContent, ['pullingIcon', 'pullingText', 'refreshingSpinner', 'refreshingText']);
var IonReorder = /** @class */ (function () {
    function IonReorder(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonReorder.decorators = [
        { type: Component, args: [{ selector: 'ion-reorder', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonReorder.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonReorder;
}());
var IonReorderGroup = /** @class */ (function () {
    function IonReorderGroup(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionItemReorder']);
    }
    IonReorderGroup.decorators = [
        { type: Component, args: [{ selector: 'ion-reorder-group', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['disabled'] },] },
    ];
    /** @nocollapse */
    IonReorderGroup.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonReorderGroup;
}());
proxyMethods(IonReorderGroup, ['complete']);
proxyInputs(IonReorderGroup, ['disabled']);
var IonRippleEffect = /** @class */ (function () {
    function IonRippleEffect(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonRippleEffect.decorators = [
        { type: Component, args: [{ selector: 'ion-ripple-effect', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['type'] },] },
    ];
    /** @nocollapse */
    IonRippleEffect.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRippleEffect;
}());
proxyMethods(IonRippleEffect, ['addRipple']);
proxyInputs(IonRippleEffect, ['type']);
var IonRow = /** @class */ (function () {
    function IonRow(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonRow.decorators = [
        { type: Component, args: [{ selector: 'ion-row', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonRow.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonRow;
}());
var IonSearchbar = /** @class */ (function () {
    function IonSearchbar(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionInput', 'ionChange', 'ionCancel', 'ionClear', 'ionBlur', 'ionFocus']);
    }
    IonSearchbar.decorators = [
        { type: Component, args: [{ selector: 'ion-searchbar', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'debounce', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value'] },] },
    ];
    /** @nocollapse */
    IonSearchbar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSearchbar;
}());
proxyMethods(IonSearchbar, ['setFocus']);
proxyInputs(IonSearchbar, ['color', 'mode', 'animated', 'autocomplete', 'autocorrect', 'cancelButtonIcon', 'cancelButtonText', 'clearIcon', 'debounce', 'placeholder', 'searchIcon', 'showCancelButton', 'spellcheck', 'type', 'value']);
var IonSegment = /** @class */ (function () {
    function IonSegment(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionStyle']);
    }
    IonSegment.decorators = [
        { type: Component, args: [{ selector: 'ion-segment', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode', 'disabled', 'scrollable', 'value'] },] },
    ];
    /** @nocollapse */
    IonSegment.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSegment;
}());
proxyInputs(IonSegment, ['color', 'mode', 'disabled', 'scrollable', 'value']);
var IonSegmentButton = /** @class */ (function () {
    function IonSegmentButton(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSelect']);
    }
    IonSegmentButton.decorators = [
        { type: Component, args: [{ selector: 'ion-segment-button', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'checked', 'disabled', 'layout', 'value'] },] },
    ];
    /** @nocollapse */
    IonSegmentButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSegmentButton;
}());
proxyInputs(IonSegmentButton, ['mode', 'checked', 'disabled', 'layout', 'value']);
var IonSelect = /** @class */ (function () {
    function IonSelect(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionCancel', 'ionFocus', 'ionBlur']);
    }
    IonSelect.decorators = [
        { type: Component, args: [{ selector: 'ion-select', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'disabled', 'cancelText', 'okText', 'placeholder', 'name', 'selectedText', 'multiple', 'interface', 'interfaceOptions', 'value'] },] },
    ];
    /** @nocollapse */
    IonSelect.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSelect;
}());
proxyMethods(IonSelect, ['open']);
proxyInputs(IonSelect, ['mode', 'disabled', 'cancelText', 'okText', 'placeholder', 'name', 'selectedText', 'multiple', 'interface', 'interfaceOptions', 'value']);
var IonSelectOption = /** @class */ (function () {
    function IonSelectOption(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonSelectOption.decorators = [
        { type: Component, args: [{ selector: 'ion-select-option', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['disabled', 'selected', 'value'] },] },
    ];
    /** @nocollapse */
    IonSelectOption.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSelectOption;
}());
proxyInputs(IonSelectOption, ['disabled', 'selected', 'value']);
var IonSkeletonText = /** @class */ (function () {
    function IonSkeletonText(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonSkeletonText.decorators = [
        { type: Component, args: [{ selector: 'ion-skeleton-text', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['width'] },] },
    ];
    /** @nocollapse */
    IonSkeletonText.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSkeletonText;
}());
proxyInputs(IonSkeletonText, ['width']);
var IonSlide = /** @class */ (function () {
    function IonSlide(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonSlide.decorators = [
        { type: Component, args: [{ selector: 'ion-slide', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonSlide.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSlide;
}());
var IonSlides = /** @class */ (function () {
    function IonSlides(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionSlidesDidLoad', 'ionSlideTap', 'ionSlideDoubleTap', 'ionSlideWillChange', 'ionSlideDidChange', 'ionSlideNextStart', 'ionSlidePrevStart', 'ionSlideNextEnd', 'ionSlidePrevEnd', 'ionSlideTransitionStart', 'ionSlideTransitionEnd', 'ionSlideDrag', 'ionSlideReachStart', 'ionSlideReachEnd', 'ionSlideTouchStart', 'ionSlideTouchEnd']);
    }
    IonSlides.decorators = [
        { type: Component, args: [{ selector: 'ion-slides', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'options', 'pager', 'scrollbar'] },] },
    ];
    /** @nocollapse */
    IonSlides.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSlides;
}());
proxyMethods(IonSlides, ['update', 'slideTo', 'slideNext', 'slidePrev', 'getActiveIndex', 'getPreviousIndex', 'length', 'isEnd', 'isBeginning', 'startAutoplay', 'stopAutoplay', 'lockSwipeToNext', 'lockSwipeToPrev', 'lockSwipes']);
proxyInputs(IonSlides, ['mode', 'options', 'pager', 'scrollbar']);
var IonSpinner = /** @class */ (function () {
    function IonSpinner(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonSpinner.decorators = [
        { type: Component, args: [{ selector: 'ion-spinner', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'duration', 'name', 'paused'] },] },
    ];
    /** @nocollapse */
    IonSpinner.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSpinner;
}());
proxyInputs(IonSpinner, ['color', 'duration', 'name', 'paused']);
var IonSplitPane = /** @class */ (function () {
    function IonSplitPane(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionSplitPaneVisible']);
    }
    IonSplitPane.decorators = [
        { type: Component, args: [{ selector: 'ion-split-pane', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['contentId', 'disabled', 'when'] },] },
    ];
    /** @nocollapse */
    IonSplitPane.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonSplitPane;
}());
proxyInputs(IonSplitPane, ['contentId', 'disabled', 'when']);
var IonTabBar = /** @class */ (function () {
    function IonTabBar(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonTabBar.decorators = [
        { type: Component, args: [{ selector: 'ion-tab-bar', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'color', 'selectedTab', 'translucent'] },] },
    ];
    /** @nocollapse */
    IonTabBar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonTabBar;
}());
proxyInputs(IonTabBar, ['mode', 'color', 'selectedTab', 'translucent']);
var IonTabButton = /** @class */ (function () {
    function IonTabButton(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonTabButton.decorators = [
        { type: Component, args: [{ selector: 'ion-tab-button', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['selected', 'mode', 'layout', 'href', 'tab', 'disabled'] },] },
    ];
    /** @nocollapse */
    IonTabButton.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonTabButton;
}());
proxyInputs(IonTabButton, ['selected', 'mode', 'layout', 'href', 'tab', 'disabled']);
var IonText = /** @class */ (function () {
    function IonText(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonText.decorators = [
        { type: Component, args: [{ selector: 'ion-text', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonText.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonText;
}());
proxyInputs(IonText, ['color', 'mode']);
var IonTextarea = /** @class */ (function () {
    function IonTextarea(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionInput', 'ionBlur', 'ionFocus']);
    }
    IonTextarea.decorators = [
        { type: Component, args: [{ selector: 'ion-textarea', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'color', 'autocapitalize', 'autofocus', 'clearOnEdit', 'debounce', 'disabled', 'maxlength', 'minlength', 'name', 'placeholder', 'readonly', 'required', 'spellcheck', 'cols', 'rows', 'wrap', 'value'] },] },
    ];
    /** @nocollapse */
    IonTextarea.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonTextarea;
}());
proxyMethods(IonTextarea, ['setFocus']);
proxyInputs(IonTextarea, ['mode', 'color', 'autocapitalize', 'autofocus', 'clearOnEdit', 'debounce', 'disabled', 'maxlength', 'minlength', 'name', 'placeholder', 'readonly', 'required', 'spellcheck', 'cols', 'rows', 'wrap', 'value']);
var IonThumbnail = /** @class */ (function () {
    function IonThumbnail(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonThumbnail.decorators = [
        { type: Component, args: [{ selector: 'ion-thumbnail', changeDetection: 0, template: '<ng-content></ng-content>' },] },
    ];
    /** @nocollapse */
    IonThumbnail.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonThumbnail;
}());
var IonTitle = /** @class */ (function () {
    function IonTitle(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonTitle.decorators = [
        { type: Component, args: [{ selector: 'ion-title', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color'] },] },
    ];
    /** @nocollapse */
    IonTitle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonTitle;
}());
proxyInputs(IonTitle, ['color']);
var IonToggle = /** @class */ (function () {
    function IonToggle(c, r) {
        c.detach();
        this.el = r.nativeElement;
        proxyOutputs(this, this.el, ['ionChange', 'ionFocus', 'ionBlur']);
    }
    IonToggle.decorators = [
        { type: Component, args: [{ selector: 'ion-toggle', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['mode', 'color', 'name', 'checked', 'disabled', 'value'] },] },
    ];
    /** @nocollapse */
    IonToggle.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonToggle;
}());
proxyInputs(IonToggle, ['mode', 'color', 'name', 'checked', 'disabled', 'value']);
var IonToolbar = /** @class */ (function () {
    function IonToolbar(c, r) {
        c.detach();
        this.el = r.nativeElement;
    }
    IonToolbar.decorators = [
        { type: Component, args: [{ selector: 'ion-toolbar', changeDetection: 0, template: '<ng-content></ng-content>', inputs: ['color', 'mode'] },] },
    ];
    /** @nocollapse */
    IonToolbar.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    return IonToolbar;
}());
proxyInputs(IonToolbar, ['color', 'mode']);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Config = /** @class */ (function () {
    function Config() {
    }
    /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    Config.prototype.get = /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    function (key, fallback) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            return c.get(key, fallback);
        }
        return null;
    };
    /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    Config.prototype.getBoolean = /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    function (key, fallback) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            return c.getBoolean(key, fallback);
        }
        return false;
    };
    /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    Config.prototype.getNumber = /**
     * @param {?} key
     * @param {?=} fallback
     * @return {?}
     */
    function (key, fallback) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            return c.getNumber(key, fallback);
        }
        return 0;
    };
    /**
     * @param {?} key
     * @param {?=} value
     * @return {?}
     */
    Config.prototype.set = /**
     * @param {?} key
     * @param {?=} value
     * @return {?}
     */
    function (key, value) {
        /** @type {?} */
        var c = getConfig();
        if (c) {
            c.set(key, value);
        }
    };
    Config.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */ Config.ngInjectableDef = defineInjectable({ factory: function Config_Factory() { return new Config(); }, token: Config, providedIn: "root" });
    return Config;
}());
/** @type {?} */
var ConfigToken = new InjectionToken('USERCONFIG');
/**
 * @return {?}
 */
function getConfig() {
    /** @type {?} */
    var win = (/** @type {?} */ (window));
    if (typeof win !== 'undefined') {
        /** @type {?} */
        var Ionic = win.Ionic;
        if (Ionic && Ionic.config) {
            return Ionic.config;
        }
    }
    return null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description
 * NavParams are an object that exists on a page and can contain data for that particular view.
 * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
 * option with a simple `get` method.
 *
 * \@usage
 * ```ts
 * import { NavParams } from '\@ionic/angular';
 *
 * export class MyClass{
 *
 *  constructor(navParams: NavParams){
 *    // userParams is an object we have in our nav-parameters
 *    navParams.get('userParams');
 *  }
 *
 * }
 * ```
 */
var  /**
 * \@description
 * NavParams are an object that exists on a page and can contain data for that particular view.
 * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
 * option with a simple `get` method.
 *
 * \@usage
 * ```ts
 * import { NavParams } from '\@ionic/angular';
 *
 * export class MyClass{
 *
 *  constructor(navParams: NavParams){
 *    // userParams is an object we have in our nav-parameters
 *    navParams.get('userParams');
 *  }
 *
 * }
 * ```
 */
NavParams = /** @class */ (function () {
    function NavParams(data) {
        if (data === void 0) { data = {}; }
        this.data = data;
    }
    /**
     * Get the value of a nav-parameter for the current view
     *
     * ```ts
     * import { NavParams } from 'ionic-angular';
     *
     * export class MyClass{
     *  constructor(public navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    this.navParams.get('userParams');
     *  }
     * }
     * ```
     *
     * @param param Which param you want to look up
     */
    /**
     * Get the value of a nav-parameter for the current view
     *
     * ```ts
     * import { NavParams } from 'ionic-angular';
     *
     * export class MyClass{
     *  constructor(public navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    this.navParams.get('userParams');
     *  }
     * }
     * ```
     *
     * @param {?} param Which param you want to look up
     * @return {?}
     */
    NavParams.prototype.get = /**
     * Get the value of a nav-parameter for the current view
     *
     * ```ts
     * import { NavParams } from 'ionic-angular';
     *
     * export class MyClass{
     *  constructor(public navParams: NavParams){
     *    // userParams is an object we have in our nav-parameters
     *    this.navParams.get('userParams');
     *  }
     * }
     * ```
     *
     * @param {?} param Which param you want to look up
     * @return {?}
     */
    function (param) {
        return this.data[param];
    };
    return NavParams;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AngularDelegate = /** @class */ (function () {
    function AngularDelegate(zone, appRef) {
        this.zone = zone;
        this.appRef = appRef;
    }
    /**
     * @param {?} resolver
     * @param {?} injector
     * @param {?=} location
     * @return {?}
     */
    AngularDelegate.prototype.create = /**
     * @param {?} resolver
     * @param {?} injector
     * @param {?=} location
     * @return {?}
     */
    function (resolver, injector, location) {
        return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);
    };
    AngularDelegate.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    AngularDelegate.ctorParameters = function () { return [
        { type: NgZone },
        { type: ApplicationRef }
    ]; };
    return AngularDelegate;
}());
var AngularFrameworkDelegate = /** @class */ (function () {
    function AngularFrameworkDelegate(resolver, injector, location, appRef, zone) {
        this.resolver = resolver;
        this.injector = injector;
        this.location = location;
        this.appRef = appRef;
        this.zone = zone;
        this.elRefMap = new WeakMap();
        this.elEventsMap = new WeakMap();
    }
    /**
     * @param {?} container
     * @param {?} component
     * @param {?=} params
     * @param {?=} cssClasses
     * @return {?}
     */
    AngularFrameworkDelegate.prototype.attachViewToDom = /**
     * @param {?} container
     * @param {?} component
     * @param {?=} params
     * @param {?=} cssClasses
     * @return {?}
     */
    function (container, component, params, cssClasses) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.zone.run(function () {
                /** @type {?} */
                var el = attachView(_this.resolver, _this.injector, _this.location, _this.appRef, _this.elRefMap, _this.elEventsMap, container, component, params, cssClasses);
                resolve(el);
            });
        });
    };
    /**
     * @param {?} _container
     * @param {?} component
     * @return {?}
     */
    AngularFrameworkDelegate.prototype.removeViewFromDom = /**
     * @param {?} _container
     * @param {?} component
     * @return {?}
     */
    function (_container, component) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.zone.run(function () {
                /** @type {?} */
                var componentRef = _this.elRefMap.get(component);
                if (componentRef) {
                    componentRef.destroy();
                    _this.elRefMap.delete(component);
                    /** @type {?} */
                    var unbindEvents = _this.elEventsMap.get(component);
                    if (unbindEvents) {
                        unbindEvents();
                        _this.elEventsMap.delete(component);
                    }
                }
                resolve();
            });
        });
    };
    return AngularFrameworkDelegate;
}());
/**
 * @param {?} resolver
 * @param {?} injector
 * @param {?} location
 * @param {?} appRef
 * @param {?} elRefMap
 * @param {?} elEventsMap
 * @param {?} container
 * @param {?} component
 * @param {?} params
 * @param {?} cssClasses
 * @return {?}
 */
function attachView(resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {
    /** @type {?} */
    var factory = resolver.resolveComponentFactory(component);
    /** @type {?} */
    var childInjector = Injector.create({
        providers: getProviders(params),
        parent: injector
    });
    /** @type {?} */
    var componentRef = (location)
        ? location.createComponent(factory, location.length, childInjector)
        : factory.create(childInjector);
    /** @type {?} */
    var instance = componentRef.instance;
    /** @type {?} */
    var hostElement = componentRef.location.nativeElement;
    if (params) {
        Object.assign(instance, params);
    }
    if (cssClasses) {
        for (var _i = 0, cssClasses_1 = cssClasses; _i < cssClasses_1.length; _i++) {
            var clazz = cssClasses_1[_i];
            hostElement.classList.add(clazz);
        }
    }
    /** @type {?} */
    var unbindEvents = bindLifecycleEvents(instance, hostElement);
    container.appendChild(hostElement);
    if (!location) {
        appRef.attachView(componentRef.hostView);
    }
    componentRef.changeDetectorRef.reattach();
    elRefMap.set(hostElement, componentRef);
    elEventsMap.set(hostElement, unbindEvents);
    return hostElement;
}
/** @type {?} */
var LIFECYCLES = [
    LIFECYCLE_WILL_ENTER,
    LIFECYCLE_DID_ENTER,
    LIFECYCLE_WILL_LEAVE,
    LIFECYCLE_DID_LEAVE,
    LIFECYCLE_WILL_UNLOAD
];
/**
 * @param {?} instance
 * @param {?} element
 * @return {?}
 */
function bindLifecycleEvents(instance, element) {
    /** @type {?} */
    var unregisters = LIFECYCLES.map(function (eventName) {
        /** @type {?} */
        var handler = function (ev) {
            if (typeof instance[eventName] === 'function') {
                instance[eventName](ev.detail);
            }
        };
        element.addEventListener(eventName, handler);
        return function () {
            element.removeEventListener(eventName, handler);
        };
    });
    return function () {
        unregisters.forEach(function (fn) { return fn(); });
    };
}
/** @type {?} */
var NavParamsToken = new InjectionToken('NavParamsToken');
/**
 * @param {?} params
 * @return {?}
 */
function getProviders(params) {
    return [
        {
            provide: NavParamsToken, useValue: params
        },
        {
            provide: NavParams, useFactory: provideNavParamsInjectable, deps: [NavParamsToken]
        }
    ];
}
/**
 * @param {?} params
 * @return {?}
 */
function provideNavParamsInjectable(params) {
    return new NavParams(params);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} views
 * @param {?} view
 * @param {?} direction
 * @return {?}
 */
function insertView(views, view, direction) {
    if (direction === 'root') {
        return setRoot(views, view);
    }
    else if (direction === 'forward') {
        return setForward(views, view);
    }
    else {
        return setBack(views, view);
    }
}
/**
 * @param {?} views
 * @param {?} view
 * @return {?}
 */
function setRoot(views, view) {
    views = views.filter(function (v) { return v.stackId !== view.stackId; });
    views.push(view);
    return views;
}
/**
 * @param {?} views
 * @param {?} view
 * @return {?}
 */
function setForward(views, view) {
    /** @type {?} */
    var index = views.indexOf(view);
    if (index >= 0) {
        views = views.filter(function (v) { return v.stackId !== view.stackId || v.id <= view.id; });
    }
    else {
        views.push(view);
    }
    return views;
}
/**
 * @param {?} views
 * @param {?} view
 * @return {?}
 */
function setBack(views, view) {
    /** @type {?} */
    var index = views.indexOf(view);
    if (index >= 0) {
        return views.filter(function (v) { return v.stackId !== view.stackId || v.id <= view.id; });
    }
    else {
        return setRoot(views, view);
    }
}
/**
 * @param {?} router
 * @param {?} activatedRoute
 * @return {?}
 */
function getUrl(router, activatedRoute) {
    /** @type {?} */
    var urlTree = router.createUrlTree(['.'], { relativeTo: activatedRoute });
    return router.serializeUrl(urlTree);
}
/**
 * @param {?} enteringView
 * @param {?} leavingView
 * @return {?}
 */
function isTabSwitch(enteringView, leavingView) {
    if (!leavingView) {
        return false;
    }
    return enteringView.stackId !== leavingView.stackId;
}
/**
 * @param {?} prefixUrl
 * @param {?} url
 * @return {?}
 */
function computeStackId(prefixUrl, url) {
    if (!prefixUrl) {
        return undefined;
    }
    /** @type {?} */
    var segments = toSegments(url);
    for (var i = 0; i < segments.length; i++) {
        if (i >= prefixUrl.length) {
            return segments[i];
        }
        if (segments[i] !== prefixUrl[i]) {
            return undefined;
        }
    }
    return undefined;
}
/**
 * @param {?} path
 * @return {?}
 */
function toSegments(path) {
    return path
        .split('/')
        .map(function (s) { return s.trim(); })
        .filter(function (s) { return s !== ''; });
}
/**
 * @param {?} view
 * @return {?}
 */
function destroyView(view) {
    if (view) {
        // TODO lifecycle event
        view.ref.destroy();
        view.unlistenEvents();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StackController = /** @class */ (function () {
    function StackController(tabsPrefix, containerEl, router, navCtrl, zone) {
        this.containerEl = containerEl;
        this.router = router;
        this.navCtrl = navCtrl;
        this.zone = zone;
        this.viewsSnapshot = [];
        this.views = [];
        this.skipTransition = false;
        this.nextId = 0;
        this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;
    }
    /**
     * @param {?} ref
     * @param {?} activatedRoute
     * @return {?}
     */
    StackController.prototype.createView = /**
     * @param {?} ref
     * @param {?} activatedRoute
     * @return {?}
     */
    function (ref, activatedRoute) {
        /** @type {?} */
        var url = getUrl(this.router, activatedRoute);
        /** @type {?} */
        var element = (/** @type {?} */ ((ref && ref.location && ref.location.nativeElement)));
        /** @type {?} */
        var unlistenEvents = bindLifecycleEvents(ref.instance, element);
        return {
            id: this.nextId++,
            stackId: computeStackId(this.tabsPrefix, url),
            unlistenEvents: unlistenEvents,
            element: element,
            ref: ref,
            url: url,
        };
    };
    /**
     * @param {?} activatedRoute
     * @return {?}
     */
    StackController.prototype.getExistingView = /**
     * @param {?} activatedRoute
     * @return {?}
     */
    function (activatedRoute) {
        /** @type {?} */
        var activatedUrlKey = getUrl(this.router, activatedRoute);
        /** @type {?} */
        var view = this.views.find(function (vw) { return vw.url === activatedUrlKey; });
        if (view) {
            view.ref.changeDetectorRef.reattach();
        }
        return view;
    };
    /**
     * @param {?} enteringView
     * @return {?}
     */
    StackController.prototype.setActive = /**
     * @param {?} enteringView
     * @return {?}
     */
    function (enteringView) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, direction, animation, leavingView;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.navCtrl.consumeTransition(), direction = _a.direction, animation = _a.animation;
                        leavingView = this.activeView;
                        if (isTabSwitch(enteringView, leavingView)) {
                            direction = 'back';
                            animation = undefined;
                        }
                        this.insertView(enteringView, direction);
                        return [4 /*yield*/, this.transition(enteringView, leavingView, animation, this.canGoBack(1), false)];
                    case 1:
                        _b.sent();
                        requestAnimationFrame(function () { return _this.cleanup(); });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    StackController.prototype.canGoBack = /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        if (stackId === void 0) { stackId = this.getActiveStackId(); }
        return this.getStack(stackId).length > deep;
    };
    /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    StackController.prototype.pop = /**
     * @param {?} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        var _this = this;
        if (stackId === void 0) { stackId = this.getActiveStackId(); }
        return this.zone.run(function () {
            /** @type {?} */
            var views = _this.getStack(stackId);
            /** @type {?} */
            var view = views[views.length - deep - 1];
            return _this.navCtrl.navigateBack(view.url);
        });
    };
    /**
     * @return {?}
     */
    StackController.prototype.startBackTransition = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var leavingView = this.activeView;
        if (leavingView) {
            /** @type {?} */
            var views = this.getStack(leavingView.stackId);
            /** @type {?} */
            var enteringView = views[views.length - 2];
            enteringView.ref.changeDetectorRef.reattach();
            this.transition(enteringView, // entering view
            leavingView, // leaving view
            'back', true, true);
        }
    };
    /**
     * @param {?} shouldComplete
     * @return {?}
     */
    StackController.prototype.endBackTransition = /**
     * @param {?} shouldComplete
     * @return {?}
     */
    function (shouldComplete) {
        if (shouldComplete) {
            this.skipTransition = true;
            this.pop(1);
        }
    };
    /**
     * @param {?=} stackId
     * @return {?}
     */
    StackController.prototype.getLastUrl = /**
     * @param {?=} stackId
     * @return {?}
     */
    function (stackId) {
        /** @type {?} */
        var views = this.getStack(stackId);
        return views.length > 0 ? views[views.length - 1] : undefined;
    };
    /**
     * @return {?}
     */
    StackController.prototype.getActiveStackId = /**
     * @return {?}
     */
    function () {
        return this.activeView ? this.activeView.stackId : undefined;
    };
    /**
     * @return {?}
     */
    StackController.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.containerEl = (/** @type {?} */ (undefined));
        this.views.forEach(destroyView);
        this.activeView = undefined;
        this.views = [];
    };
    /**
     * @private
     * @param {?} stackId
     * @return {?}
     */
    StackController.prototype.getStack = /**
     * @private
     * @param {?} stackId
     * @return {?}
     */
    function (stackId) {
        return this.views.filter(function (v) { return v.stackId === stackId; });
    };
    /**
     * @private
     * @param {?} enteringView
     * @param {?} direction
     * @return {?}
     */
    StackController.prototype.insertView = /**
     * @private
     * @param {?} enteringView
     * @param {?} direction
     * @return {?}
     */
    function (enteringView, direction) {
        this.activeView = enteringView;
        this.views = insertView(this.views, enteringView, direction);
    };
    /**
     * @private
     * @return {?}
     */
    StackController.prototype.cleanup = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var activeRoute = this.activeView;
        /** @type {?} */
        var views = this.views;
        this.viewsSnapshot
            .filter(function (view) { return !views.includes(view); })
            .forEach(function (view) { return destroyView(view); });
        views.forEach(function (view) {
            if (view !== activeRoute) {
                /** @type {?} */
                var element = view.element;
                element.setAttribute('aria-hidden', 'true');
                element.classList.add('ion-page-hidden');
                view.ref.changeDetectorRef.detach();
            }
        });
        this.viewsSnapshot = views.slice();
    };
    /**
     * @private
     * @param {?} enteringView
     * @param {?} leavingView
     * @param {?} direction
     * @param {?} showGoBack
     * @param {?} progressAnimation
     * @return {?}
     */
    StackController.prototype.transition = /**
     * @private
     * @param {?} enteringView
     * @param {?} leavingView
     * @param {?} direction
     * @param {?} showGoBack
     * @param {?} progressAnimation
     * @return {?}
     */
    function (enteringView, leavingView, direction, showGoBack, progressAnimation) {
        return __awaiter(this, void 0, void 0, function () {
            var enteringEl, leavingEl, containerEl;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.runningTransition !== undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.runningTransition];
                    case 1:
                        _a.sent();
                        this.runningTransition = undefined;
                        _a.label = 2;
                    case 2:
                        if (this.skipTransition) {
                            this.skipTransition = false;
                            return [2 /*return*/];
                        }
                        enteringEl = enteringView ? enteringView.element : undefined;
                        leavingEl = leavingView ? leavingView.element : undefined;
                        containerEl = this.containerEl;
                        if (!(enteringEl && enteringEl !== leavingEl)) return [3 /*break*/, 5];
                        enteringEl.classList.add('ion-page', 'ion-page-invisible');
                        if (enteringEl.parentElement !== containerEl) {
                            containerEl.appendChild(enteringEl);
                        }
                        return [4 /*yield*/, containerEl.componentOnReady()];
                    case 3:
                        _a.sent();
                        this.runningTransition = containerEl.commit(enteringEl, leavingEl, {
                            deepWait: true,
                            duration: direction === undefined ? 0 : undefined,
                            direction: direction,
                            showGoBack: showGoBack,
                            progressAnimation: progressAnimation
                        });
                        return [4 /*yield*/, this.runningTransition];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return StackController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonRouterOutlet = /** @class */ (function () {
    function IonRouterOutlet(parentContexts, location, resolver, name, tabs, changeDetector, config, navCtrl, elementRef, router, zone, activatedRoute) {
        this.parentContexts = parentContexts;
        this.location = location;
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.config = config;
        this.activated = null;
        this.activatedView = null;
        this._activatedRoute = null;
        this.activateEvents = new EventEmitter();
        this.deactivateEvents = new EventEmitter();
        this.nativeEl = elementRef.nativeElement;
        this.name = name || PRIMARY_OUTLET;
        this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;
        this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone);
        parentContexts.onChildOutletCreated(this.name, (/** @type {?} */ (this)));
    }
    Object.defineProperty(IonRouterOutlet.prototype, "animated", {
        set: /**
         * @param {?} animated
         * @return {?}
         */
        function (animated) {
            this.nativeEl.animated = animated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "swipeGesture", {
        set: /**
         * @param {?} swipe
         * @return {?}
         */
        function (swipe) {
            var _this = this;
            this._swipeGesture = swipe;
            this.nativeEl.swipeHandler = swipe ? {
                canStart: function () { return _this.stackCtrl.canGoBack(1); },
                onStart: function () { return _this.stackCtrl.startBackTransition(); },
                onEnd: function (shouldContinue) { return _this.stackCtrl.endBackTransition(shouldContinue); }
            } : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stackCtrl.destroy();
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.getContext = /**
     * @return {?}
     */
    function () {
        return this.parentContexts.getContext(this.name);
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.activated) {
            // If the outlet was not instantiated at the time the route got activated we need to populate
            // the outlet when it is initialized (ie inside a NgIf)
            /** @type {?} */
            var context = this.getContext();
            if (context && context.route) {
                this.activateWith(context.route, context.resolver || null);
            }
        }
        this.nativeEl.componentOnReady().then(function () {
            if (_this._swipeGesture === undefined) {
                _this.swipeGesture = _this.config.getBoolean('swipeBackEnabled', _this.nativeEl.mode === 'ios');
            }
        });
    };
    Object.defineProperty(IonRouterOutlet.prototype, "isActivated", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.activated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "component", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.activated) {
                throw new Error('Outlet is not activated');
            }
            return this.activated.instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "activatedRoute", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.activated) {
                throw new Error('Outlet is not activated');
            }
            return (/** @type {?} */ (this._activatedRoute));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IonRouterOutlet.prototype, "activatedRouteData", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._activatedRoute) {
                return this._activatedRoute.snapshot.data;
            }
            return {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     * @return {?}
     */
    IonRouterOutlet.prototype.detach = /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     * @return {?}
     */
    function () {
        throw new Error('incompatible reuse strategy');
    };
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     * @param {?} _ref
     * @param {?} _activatedRoute
     * @return {?}
     */
    IonRouterOutlet.prototype.attach = /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     * @param {?} _ref
     * @param {?} _activatedRoute
     * @return {?}
     */
    function (_ref, _activatedRoute) {
        throw new Error('incompatible reuse strategy');
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.deactivate = /**
     * @return {?}
     */
    function () {
        if (this.activated) {
            if (this.activatedView) {
                this.activatedView.savedData = new Map((/** @type {?} */ (this.getContext())).children['contexts']);
            }
            /** @type {?} */
            var c = this.component;
            this.activatedView = null;
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
        }
    };
    /**
     * @param {?} activatedRoute
     * @param {?} resolver
     * @return {?}
     */
    IonRouterOutlet.prototype.activateWith = /**
     * @param {?} activatedRoute
     * @param {?} resolver
     * @return {?}
     */
    function (activatedRoute, resolver) {
        var _this = this;
        if (this.isActivated) {
            throw new Error('Cannot activate an already activated outlet');
        }
        this._activatedRoute = activatedRoute;
        /** @type {?} */
        var cmpRef;
        /** @type {?} */
        var enteringView = this.stackCtrl.getExistingView(activatedRoute);
        if (enteringView) {
            cmpRef = this.activated = enteringView.ref;
            /** @type {?} */
            var saved = enteringView.savedData;
            if (saved) {
                // self-restore
                /** @type {?} */
                var context = (/** @type {?} */ (this.getContext()));
                context.children['contexts'] = saved;
            }
        }
        else {
            /** @type {?} */
            var snapshot = ((/** @type {?} */ (activatedRoute)))._futureSnapshot;
            /** @type {?} */
            var component = (/** @type {?} */ ((/** @type {?} */ (snapshot.routeConfig)).component));
            resolver = resolver || this.resolver;
            /** @type {?} */
            var factory = resolver.resolveComponentFactory(component);
            /** @type {?} */
            var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
            /** @type {?} */
            var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
            cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector);
            // Calling `markForCheck` to make sure we will run the change detection when the
            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
            enteringView = this.stackCtrl.createView(this.activated, activatedRoute);
            this.changeDetector.markForCheck();
        }
        this.activatedView = enteringView;
        this.stackCtrl.setActive(enteringView).then(function () {
            _this.activateEvents.emit(cmpRef.instance);
            emitEvent(_this.nativeEl, (/** @type {?} */ (enteringView)));
        });
    };
    /**
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    IonRouterOutlet.prototype.canGoBack = /**
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        if (deep === void 0) { deep = 1; }
        return this.stackCtrl.canGoBack(deep, stackId);
    };
    /**
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    IonRouterOutlet.prototype.pop = /**
     * @param {?=} deep
     * @param {?=} stackId
     * @return {?}
     */
    function (deep, stackId) {
        if (deep === void 0) { deep = 1; }
        return this.stackCtrl.pop(deep, stackId);
    };
    /**
     * @param {?=} stackId
     * @return {?}
     */
    IonRouterOutlet.prototype.getLastUrl = /**
     * @param {?=} stackId
     * @return {?}
     */
    function (stackId) {
        /** @type {?} */
        var active = this.stackCtrl.getLastUrl(stackId);
        return active ? active.url : undefined;
    };
    /**
     * @return {?}
     */
    IonRouterOutlet.prototype.getActiveStackId = /**
     * @return {?}
     */
    function () {
        return this.stackCtrl.getActiveStackId();
    };
    IonRouterOutlet.decorators = [
        { type: Directive, args: [{
                    selector: 'ion-router-outlet',
                    exportAs: 'outlet',
                    inputs: ['animated', 'swipeGesture']
                },] },
    ];
    /** @nocollapse */
    IonRouterOutlet.ctorParameters = function () { return [
        { type: ChildrenOutletContexts },
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver },
        { type: String, decorators: [{ type: Attribute, args: ['name',] }] },
        { type: String, decorators: [{ type: Optional }, { type: Attribute, args: ['tabs',] }] },
        { type: ChangeDetectorRef },
        { type: Config },
        { type: NavController },
        { type: ElementRef },
        { type: Router },
        { type: NgZone },
        { type: ActivatedRoute }
    ]; };
    IonRouterOutlet.propDecorators = {
        activateEvents: [{ type: Output, args: ['activate',] }],
        deactivateEvents: [{ type: Output, args: ['deactivate',] }]
    };
    return IonRouterOutlet;
}());
/**
 * @param {?} el
 * @param {?} view
 * @return {?}
 */
function emitEvent(el, view) {
    /** @type {?} */
    var ev = new CustomEvent('ionRouterOutletActivated', {
        bubbles: true,
        cancelable: true,
        detail: { view: view }
    });
    el.dispatchEvent(ev);
}
var OutletInjector = /** @class */ (function () {
    function OutletInjector(route, childContexts, parent) {
        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
    }
    /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    OutletInjector.prototype.get = /**
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    function (token, notFoundValue) {
        if (token === ActivatedRoute) {
            return this.route;
        }
        if (token === ChildrenOutletContexts) {
            return this.childContexts;
        }
        // tslint:disable-next-line
        return this.parent.get(token, notFoundValue);
    };
    return OutletInjector;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonTabs = /** @class */ (function () {
    function IonTabs(navCtrl) {
        this.navCtrl = navCtrl;
    }
    /**
     * @param {?} detail
     * @return {?}
     */
    IonTabs.prototype.onPageSelected = /**
     * @param {?} detail
     * @return {?}
     */
    function (detail) {
        if (this.tabBar) {
            this.tabBar.selectedTab = detail.view.stackId;
        }
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    IonTabs.prototype.select = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        /** @type {?} */
        var selected = this.outlet.getActiveStackId() === tab;
        /** @type {?} */
        var href = this.outlet.tabsPrefix + "/" + tab;
        /** @type {?} */
        var url = selected
            ? href
            : this.outlet.getLastUrl(tab) || href;
        return this.navCtrl.navigateRoot(url, {
            animated: true,
            animationDirection: 'back'
        });
    };
    IonTabs.decorators = [
        { type: Component, args: [{
                    selector: 'ion-tabs',
                    template: "\n    <ng-content select=\"[slot=top]\"></ng-content>\n    <div class=\"tabs-inner\">\n      <ion-router-outlet #outlet tabs=\"true\"></ion-router-outlet>\n    </div>\n    <ng-content></ng-content>",
                    styles: ["\n    :host {\n      display: flex;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n\n      flex-direction: column;\n\n      width: 100%;\n      height: 100%;\n\n      contain: layout size style;\n      z-index: $z-index-page-container;\n    }\n    .tabs-inner {\n      position: relative;\n\n      flex: 1;\n\n      contain: layout size style;\n    }"
                    ]
                },] },
    ];
    /** @nocollapse */
    IonTabs.ctorParameters = function () { return [
        { type: NavController }
    ]; };
    IonTabs.propDecorators = {
        outlet: [{ type: ViewChild, args: ['outlet', { read: IonRouterOutlet },] }],
        tabBar: [{ type: ContentChild, args: [IonTabBar,] }],
        onPageSelected: [{ type: HostListener, args: ['ionRouterOutletActivated', ['$event.detail'],] }],
        select: [{ type: HostListener, args: ['ionTabButtonClick', ['$event.detail.tab'],] }]
    };
    return IonTabs;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonBackButtonDelegate = /** @class */ (function () {
    function IonBackButtonDelegate(routerOutlet, navCtrl, elementRef) {
        this.routerOutlet = routerOutlet;
        this.navCtrl = navCtrl;
        this.elementRef = elementRef;
    }
    Object.defineProperty(IonBackButtonDelegate.prototype, "defaultHref", {
        get: /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement.defaultHref;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.elementRef.nativeElement.defaultHref = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} ev
     * @return {?}
     */
    IonBackButtonDelegate.prototype.onClick = /**
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.routerOutlet && this.routerOutlet.canGoBack()) {
            this.routerOutlet.pop();
            ev.preventDefault();
        }
        else if (this.defaultHref != null) {
            this.navCtrl.navigateBack(this.defaultHref);
            ev.preventDefault();
        }
    };
    IonBackButtonDelegate.decorators = [
        { type: Directive, args: [{
                    selector: 'ion-back-button',
                    inputs: ['defaultHref']
                },] },
    ];
    /** @nocollapse */
    IonBackButtonDelegate.ctorParameters = function () { return [
        { type: IonRouterOutlet, decorators: [{ type: Optional }] },
        { type: NavController },
        { type: ElementRef }
    ]; };
    IonBackButtonDelegate.propDecorators = {
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return IonBackButtonDelegate;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavDelegate = /** @class */ (function () {
    function NavDelegate(ref, resolver, injector, angularDelegate, location) {
        ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);
    }
    NavDelegate.decorators = [
        { type: Directive, args: [{
                    selector: 'ion-nav',
                },] },
    ];
    /** @nocollapse */
    NavDelegate.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: AngularDelegate },
        { type: ViewContainerRef }
    ]; };
    return NavDelegate;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RouterLinkDelegate = /** @class */ (function () {
    function RouterLinkDelegate(locationStrategy, navCtrl, elementRef, router, routerLink) {
        this.locationStrategy = locationStrategy;
        this.navCtrl = navCtrl;
        this.elementRef = elementRef;
        this.router = router;
        this.routerLink = routerLink;
        this.routerDirection = 'forward';
    }
    /**
     * @return {?}
     */
    RouterLinkDelegate.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.updateTargetUrlAndHref();
    };
    /**
     * @return {?}
     */
    RouterLinkDelegate.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.updateTargetUrlAndHref();
    };
    /**
     * @return {?}
     */
    RouterLinkDelegate.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    /**
     * @private
     * @return {?}
     */
    RouterLinkDelegate.prototype.updateTargetUrlAndHref = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.routerLink) {
            /** @type {?} */
            var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));
            this.elementRef.nativeElement.href = href;
        }
    };
    /**
     * @param {?} ev
     * @return {?}
     */
    RouterLinkDelegate.prototype.onClick = /**
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        this.navCtrl.setDirection(this.routerDirection);
        ev.preventDefault();
    };
    RouterLinkDelegate.decorators = [
        { type: Directive, args: [{
                    selector: '[routerLink]',
                    inputs: ['routerDirection']
                },] },
    ];
    /** @nocollapse */
    RouterLinkDelegate.ctorParameters = function () { return [
        { type: LocationStrategy },
        { type: NavController },
        { type: ElementRef },
        { type: Router },
        { type: RouterLink, decorators: [{ type: Optional }] }
    ]; };
    RouterLinkDelegate.propDecorators = {
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return RouterLinkDelegate;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var VirtualFooter = /** @class */ (function () {
    function VirtualFooter(templateRef) {
        this.templateRef = templateRef;
    }
    VirtualFooter.decorators = [
        { type: Directive, args: [{ selector: '[virtualFooter]' },] },
    ];
    /** @nocollapse */
    VirtualFooter.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return VirtualFooter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var VirtualHeader = /** @class */ (function () {
    function VirtualHeader(templateRef) {
        this.templateRef = templateRef;
    }
    VirtualHeader.decorators = [
        { type: Directive, args: [{ selector: '[virtualHeader]' },] },
    ];
    /** @nocollapse */
    VirtualHeader.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return VirtualHeader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var VirtualItem = /** @class */ (function () {
    function VirtualItem(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
    VirtualItem.decorators = [
        { type: Directive, args: [{ selector: '[virtualItem]' },] },
    ];
    /** @nocollapse */
    VirtualItem.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    return VirtualItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonVirtualScroll = /** @class */ (function () {
    function IonVirtualScroll(zone, iterableDiffers, elementRef) {
        this.zone = zone;
        this.iterableDiffers = iterableDiffers;
        this.refMap = new WeakMap();
        this.el = (/** @type {?} */ (elementRef.nativeElement));
        this.el.nodeRender = this.nodeRender.bind(this);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    IonVirtualScroll.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.trackBy && 'items' in changes) {
            // React on virtualScroll changes only once all inputs have been initialized
            /** @type {?} */
            var value = changes['items'].currentValue;
            if (this.differ === undefined && value != null) {
                try {
                    this.differ = this.iterableDiffers.find(value).create(this.trackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object '" + value + "'. VirtualScroll only supports binding to Iterables such as Arrays.");
                }
            }
        }
    };
    /**
     * @return {?}
     */
    IonVirtualScroll.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        // and if there actually are changes
        /** @type {?} */
        var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;
        if (changes === null) {
            return;
        }
        // TODO: optimize
        this.checkRange(0);
    };
    /**
     * @private
     * @param {?} el
     * @param {?} cell
     * @param {?} index
     * @return {?}
     */
    IonVirtualScroll.prototype.nodeRender = /**
     * @private
     * @param {?} el
     * @param {?} cell
     * @param {?} index
     * @return {?}
     */
    function (el, cell, index) {
        var _this = this;
        return this.zone.run(function () {
            /** @type {?} */
            var node;
            if (!el) {
                node = _this.itmTmp.viewContainer.createEmbeddedView(_this.getComponent(cell.type), { $implicit: cell.value, index: index }, index);
                el = getElement(node);
                _this.refMap.set(el, node);
            }
            else {
                node = (/** @type {?} */ (_this.refMap.get(el)));
                /** @type {?} */
                var ctx = node.context;
                ctx.$implicit = cell.value;
                ctx.index = cell.index;
            }
            // run sync change detections
            node.detectChanges();
            return el;
        });
    };
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    IonVirtualScroll.prototype.getComponent = /**
     * @private
     * @param {?} type
     * @return {?}
     */
    function (type) {
        switch (type) {
            case 'item': return this.itmTmp.templateRef;
            case 'header': return this.hdrTmp.templateRef;
            case 'footer': return this.ftrTmp.templateRef;
        }
        throw new Error('template for virtual item was not provided');
    };
    IonVirtualScroll.decorators = [
        { type: Component, args: [{
                    selector: 'ion-virtual-scroll',
                    template: '<ng-content></ng-content>',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    inputs: [
                        'approxItemHeight',
                        'approxHeaderHeight',
                        'approxFooterHeight',
                        'headerFn',
                        'footerFn',
                        'items',
                        'itemHeight',
                        'trackBy'
                    ]
                },] },
    ];
    /** @nocollapse */
    IonVirtualScroll.ctorParameters = function () { return [
        { type: NgZone },
        { type: IterableDiffers },
        { type: ElementRef }
    ]; };
    IonVirtualScroll.propDecorators = {
        itmTmp: [{ type: ContentChild, args: [VirtualItem,] }],
        hdrTmp: [{ type: ContentChild, args: [VirtualHeader,] }],
        ftrTmp: [{ type: ContentChild, args: [VirtualFooter,] }]
    };
    return IonVirtualScroll;
}());
/**
 * @param {?} view
 * @return {?}
 */
function getElement(view) {
    /** @type {?} */
    var rootNodes = view.rootNodes;
    for (var i = 0; i < rootNodes.length; i++) {
        if (rootNodes[i].nodeType === 1) {
            return rootNodes[i];
        }
    }
    throw new Error('virtual element was not created');
}
proxyInputs(IonVirtualScroll, [
    'approxItemHeight',
    'approxHeaderHeight',
    'approxFooterHeight',
    'headerFn',
    'footerFn',
    'items',
    'itemHeight'
]);
proxyMethods(IonVirtualScroll, [
    'checkEnd',
    'checkRange',
    'positionForItem'
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} ctrlName
 * @param {?} methodName
 * @param {...?} args
 * @return {?}
 */
function proxyMethod(ctrlName, methodName) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    /** @type {?} */
    var controller = ensureElementInBody(ctrlName);
    return controller.componentOnReady()
        .then(function () { return ((/** @type {?} */ (controller)))[methodName].apply(controller, args); });
}
/**
 * @param {?} elementName
 * @return {?}
 */
function ensureElementInBody(elementName) {
    /** @type {?} */
    var element = document.querySelector(elementName);
    if (!element) {
        element = document.createElement(elementName);
        document.body.appendChild(element);
    }
    return (/** @type {?} */ (element));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Opts, Overlay
 */
var  /**
 * @template Opts, Overlay
 */
OverlayBaseController = /** @class */ (function () {
    function OverlayBaseController(ctrl) {
        this.ctrl = ctrl;
    }
    /**
     * @param {?=} opts
     * @return {?}
     */
    OverlayBaseController.prototype.create = /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        return proxyMethod(this.ctrl, 'create', opts);
    };
    /**
     * @param {?=} data
     * @param {?=} role
     * @param {?=} id
     * @return {?}
     */
    OverlayBaseController.prototype.dismiss = /**
     * @param {?=} data
     * @param {?=} role
     * @param {?=} id
     * @return {?}
     */
    function (data, role, id) {
        return proxyMethod(this.ctrl, 'dismiss', data, role, id);
    };
    /**
     * @return {?}
     */
    OverlayBaseController.prototype.getTop = /**
     * @return {?}
     */
    function () {
        return proxyMethod(this.ctrl, 'getTop');
    };
    return OverlayBaseController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheetController = /** @class */ (function (_super) {
    __extends(ActionSheetController, _super);
    function ActionSheetController() {
        return _super.call(this, 'ion-action-sheet-controller') || this;
    }
    ActionSheetController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    ActionSheetController.ctorParameters = function () { return []; };
    /** @nocollapse */ ActionSheetController.ngInjectableDef = defineInjectable({ factory: function ActionSheetController_Factory() { return new ActionSheetController(); }, token: ActionSheetController, providedIn: "root" });
    return ActionSheetController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AlertController = /** @class */ (function (_super) {
    __extends(AlertController, _super);
    function AlertController() {
        return _super.call(this, 'ion-alert-controller') || this;
    }
    AlertController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    AlertController.ctorParameters = function () { return []; };
    /** @nocollapse */ AlertController.ngInjectableDef = defineInjectable({ factory: function AlertController_Factory() { return new AlertController(); }, token: AlertController, providedIn: "root" });
    return AlertController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Events = /** @class */ (function () {
    function Events() {
        this.c = new Map();
    }
    /**
     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
     *
     * @param topic the topic to subscribe to
     * @param handler the event handler
     */
    /**
     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
     *
     * @param {?} topic the topic to subscribe to
     * @param {...?} handlers
     * @return {?}
     */
    Events.prototype.subscribe = /**
     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
     *
     * @param {?} topic the topic to subscribe to
     * @param {...?} handlers
     * @return {?}
     */
    function (topic) {
        var handlers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            handlers[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var topics = this.c.get(topic);
        if (!topics) {
            this.c.set(topic, topics = []);
        }
        topics.push.apply(topics, handlers);
    };
    /**
     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
     *
     * @param topic the topic to unsubscribe from
     * @param handler the event handler
     *
     * @return true if a handler was removed
     */
    /**
     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
     *
     * @param {?} topic the topic to unsubscribe from
     * @param {?=} handler the event handler
     *
     * @return {?} true if a handler was removed
     */
    Events.prototype.unsubscribe = /**
     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
     *
     * @param {?} topic the topic to unsubscribe from
     * @param {?=} handler the event handler
     *
     * @return {?} true if a handler was removed
     */
    function (topic, handler) {
        if (!handler) {
            return this.c.delete(topic);
        }
        /** @type {?} */
        var topics = this.c.get(topic);
        if (!topics) {
            return false;
        }
        // We need to find and remove a specific handler
        /** @type {?} */
        var index = topics.indexOf(handler);
        if (index < 0) {
            // Wasn't found, wasn't removed
            return false;
        }
        topics.splice(index, 1);
        if (topics.length === 0) {
            this.c.delete(topic);
        }
        return true;
    };
    /**
     * Publish an event to the given topic.
     *
     * @param topic the topic to publish to
     * @param eventData the data to send as the event
     */
    /**
     * Publish an event to the given topic.
     *
     * @param {?} topic the topic to publish to
     * @param {...?} args
     * @return {?}
     */
    Events.prototype.publish = /**
     * Publish an event to the given topic.
     *
     * @param {?} topic the topic to publish to
     * @param {...?} args
     * @return {?}
     */
    function (topic) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var topics = this.c.get(topic);
        if (!topics) {
            return null;
        }
        return topics.map(function (handler) {
            try {
                return handler.apply(void 0, args);
            }
            catch (e) {
                console.error(e);
                return null;
            }
        });
    };
    Events.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */ Events.ngInjectableDef = defineInjectable({ factory: function Events_Factory() { return new Events(); }, token: Events, providedIn: "root" });
    return Events;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LoadingController = /** @class */ (function (_super) {
    __extends(LoadingController, _super);
    function LoadingController() {
        return _super.call(this, 'ion-loading-controller') || this;
    }
    LoadingController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    LoadingController.ctorParameters = function () { return []; };
    /** @nocollapse */ LoadingController.ngInjectableDef = defineInjectable({ factory: function LoadingController_Factory() { return new LoadingController(); }, token: LoadingController, providedIn: "root" });
    return LoadingController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CTRL = 'ion-menu-controller';
var MenuController = /** @class */ (function () {
    function MenuController() {
    }
    /**
     * Programmatically open the Menu.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu is fully opened
     */
    /**
     * Programmatically open the Menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully opened
     */
    MenuController.prototype.open = /**
     * Programmatically open the Menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully opened
     */
    function (menuId) {
        return proxyMethod(CTRL, 'open', menuId);
    };
    /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu is fully closed
     */
    /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully closed
     */
    MenuController.prototype.close = /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu is fully closed
     */
    function (menuId) {
        return proxyMethod(CTRL, 'close', menuId);
    };
    /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu has been toggled
     */
    /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu has been toggled
     */
    MenuController.prototype.toggle = /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param {?=} menuId
     * @return {?} returns a promise when the menu has been toggled
     */
    function (menuId) {
        return proxyMethod(CTRL, 'toggle', menuId);
    };
    /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     */
    /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param {?} shouldEnable
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    MenuController.prototype.enable = /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param {?} shouldEnable
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    function (shouldEnable, menuId) {
        return proxyMethod(CTRL, 'enable', shouldEnable, menuId);
    };
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param shouldEnable  True if it should be swipe-able, false if not.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     */
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param {?} shouldEnable  True if it should be swipe-able, false if not.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    MenuController.prototype.swipeEnable = /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param {?} shouldEnable  True if it should be swipe-able, false if not.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu, which is useful for chaining.
     */
    function (shouldEnable, menuId) {
        return proxyMethod(CTRL, 'swipeEnable', shouldEnable, menuId);
    };
    /**
     * @param [menuId] Optionally get the menu by its id, or side.
     * @return Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    /**
     * @param {?=} menuId
     * @return {?} Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    MenuController.prototype.isOpen = /**
     * @param {?=} menuId
     * @return {?} Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    function (menuId) {
        return proxyMethod(CTRL, 'isOpen', menuId);
    };
    /**
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns true if the menu is currently enabled, otherwise false.
     */
    /**
     * @param {?=} menuId
     * @return {?} Returns true if the menu is currently enabled, otherwise false.
     */
    MenuController.prototype.isEnabled = /**
     * @param {?=} menuId
     * @return {?} Returns true if the menu is currently enabled, otherwise false.
     */
    function (menuId) {
        return proxyMethod(CTRL, 'isEnabled', menuId);
    };
    /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu if found, otherwise `null`.
     */
    /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu if found, otherwise `null`.
     */
    MenuController.prototype.get = /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param {?=} menuId
     * @return {?} Returns the instance of the menu if found, otherwise `null`.
     */
    function (menuId) {
        return proxyMethod(CTRL, 'get', menuId);
    };
    /**
     * @return Returns the instance of the menu already opened, otherwise `null`.
     */
    /**
     * @return {?} Returns the instance of the menu already opened, otherwise `null`.
     */
    MenuController.prototype.getOpen = /**
     * @return {?} Returns the instance of the menu already opened, otherwise `null`.
     */
    function () {
        return proxyMethod(CTRL, 'getOpen');
    };
    /**
     * @return Returns an array of all menu instances.
     */
    /**
     * @return {?} Returns an array of all menu instances.
     */
    MenuController.prototype.getMenus = /**
     * @return {?} Returns an array of all menu instances.
     */
    function () {
        return proxyMethod(CTRL, 'getMenus');
    };
    MenuController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */ MenuController.ngInjectableDef = defineInjectable({ factory: function MenuController_Factory() { return new MenuController(); }, token: MenuController, providedIn: "root" });
    return MenuController;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PickerController = /** @class */ (function (_super) {
    __extends(PickerController, _super);
    function PickerController() {
        return _super.call(this, 'ion-picker-controller') || this;
    }
    PickerController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    PickerController.ctorParameters = function () { return []; };
    /** @nocollapse */ PickerController.ngInjectableDef = defineInjectable({ factory: function PickerController_Factory() { return new PickerController(); }, token: PickerController, providedIn: "root" });
    return PickerController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalController = /** @class */ (function (_super) {
    __extends(ModalController, _super);
    function ModalController(angularDelegate, resolver, injector) {
        var _this = _super.call(this, 'ion-modal-controller') || this;
        _this.angularDelegate = angularDelegate;
        _this.resolver = resolver;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    ModalController.prototype.create = /**
     * @param {?} opts
     * @return {?}
     */
    function (opts) {
        return _super.prototype.create.call(this, __assign({}, opts, { delegate: this.angularDelegate.create(this.resolver, this.injector) }));
    };
    ModalController.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ModalController.ctorParameters = function () { return [
        { type: AngularDelegate },
        { type: ComponentFactoryResolver },
        { type: Injector }
    ]; };
    return ModalController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PopoverController = /** @class */ (function (_super) {
    __extends(PopoverController, _super);
    function PopoverController(angularDelegate, resolver, injector) {
        var _this = _super.call(this, 'ion-popover-controller') || this;
        _this.angularDelegate = angularDelegate;
        _this.resolver = resolver;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    PopoverController.prototype.create = /**
     * @param {?} opts
     * @return {?}
     */
    function (opts) {
        return _super.prototype.create.call(this, __assign({}, opts, { delegate: this.angularDelegate.create(this.resolver, this.injector) }));
    };
    PopoverController.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    PopoverController.ctorParameters = function () { return [
        { type: AngularDelegate },
        { type: ComponentFactoryResolver },
        { type: Injector }
    ]; };
    return PopoverController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ToastController = /** @class */ (function (_super) {
    __extends(ToastController, _super);
    function ToastController() {
        return _super.call(this, 'ion-toast-controller') || this;
    }
    ToastController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    ToastController.ctorParameters = function () { return []; };
    /** @nocollapse */ ToastController.ngInjectableDef = defineInjectable({ factory: function ToastController_Factory() { return new ToastController(); }, token: ToastController, providedIn: "root" });
    return ToastController;
}(OverlayBaseController));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DomController = /** @class */ (function () {
    function DomController() {
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    DomController.prototype.read = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        getQueue().read(cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    DomController.prototype.write = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        getQueue().write(cb);
    };
    DomController.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */ DomController.ngInjectableDef = defineInjectable({ factory: function DomController_Factory() { return new DomController(); }, token: DomController, providedIn: "root" });
    return DomController;
}());
/**
 * @return {?}
 */
function getQueue() {
    /** @type {?} */
    var Ionic = ((/** @type {?} */ (window))).Ionic;
    if (Ionic && Ionic.queue) {
        return Ionic.queue;
    }
    return {
        read: function (cb) { return window.requestAnimationFrame(cb); },
        write: function (cb) { return window.requestAnimationFrame(cb); }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IonicRouteStrategy = /** @class */ (function () {
    function IonicRouteStrategy() {
    }
    /**
     * @param {?} _route
     * @return {?}
     */
    IonicRouteStrategy.prototype.shouldDetach = /**
     * @param {?} _route
     * @return {?}
     */
    function (_route) {
        return false;
    };
    /**
     * @param {?} _route
     * @return {?}
     */
    IonicRouteStrategy.prototype.shouldAttach = /**
     * @param {?} _route
     * @return {?}
     */
    function (_route) {
        return false;
    };
    /**
     * @param {?} _route
     * @param {?} _detachedTree
     * @return {?}
     */
    IonicRouteStrategy.prototype.store = /**
     * @param {?} _route
     * @param {?} _detachedTree
     * @return {?}
     */
    function (_route, _detachedTree) {
        return;
    };
    /**
     * @param {?} _route
     * @return {?}
     */
    IonicRouteStrategy.prototype.retrieve = /**
     * @param {?} _route
     * @return {?}
     */
    function (_route) {
        return null;
    };
    /**
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    IonicRouteStrategy.prototype.shouldReuseRoute = /**
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    function (future, curr) {
        if (future.routeConfig !== curr.routeConfig) {
            return false;
        }
        if (future.component !== curr.component) {
            return false;
        }
        // checking router params
        /** @type {?} */
        var futureParams = future.params;
        /** @type {?} */
        var currentParams = curr.params;
        /** @type {?} */
        var keysA = Object.keys(futureParams);
        /** @type {?} */
        var keysB = Object.keys(currentParams);
        if (keysA.length !== keysB.length) {
            return false;
        }
        // Test for A's keys different from B.
        for (var _i = 0, keysA_1 = keysA; _i < keysA_1.length; _i++) {
            var key = keysA_1[_i];
            if (currentParams[key] !== futureParams[key]) {
                return false;
            }
        }
        return true;
    };
    return IonicRouteStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function appInitialize(config) {
    return function () {
        /** @type {?} */
        var win = (/** @type {?} */ (window));
        if (typeof win !== 'undefined') {
            /** @type {?} */
            var Ionic = win.Ionic = win.Ionic || {};
            Ionic.config = config;
            Ionic.asyncQueue = false;
            Ionic.ael = function (elm, eventName, cb, opts) {
                if (elm.__zone_symbol__addEventListener && skipZone(eventName)) {
                    elm.__zone_symbol__addEventListener(eventName, cb, opts);
                }
                else {
                    elm.addEventListener(eventName, cb, opts);
                }
            };
            Ionic.rel = function (elm, eventName, cb, opts) {
                if (elm.__zone_symbol__removeEventListener && skipZone(eventName)) {
                    elm.__zone_symbol__removeEventListener(eventName, cb, opts);
                }
                else {
                    elm.removeEventListener(eventName, cb, opts);
                }
            };
            return defineCustomElements(win, {
                exclude: ['ion-tabs', 'ion-tab']
            });
        }
    };
}
/** @type {?} */
var SKIP_ZONE = [
    'scroll',
    'resize',
    'touchstart',
    'touchmove',
    'touchend',
    'mousedown',
    'mousemove',
    'mouseup',
    'ionStyle',
];
/**
 * @param {?} eventName
 * @return {?}
 */
function skipZone(eventName) {
    return SKIP_ZONE.indexOf(eventName) >= 0;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DECLARATIONS = [
    // proxies
    IonApp,
    IonAvatar,
    IonBackButton,
    IonBackdrop,
    IonBadge,
    IonButton,
    IonButtons,
    IonCard,
    IonCardContent,
    IonCardHeader,
    IonCardSubtitle,
    IonCardTitle,
    IonCheckbox,
    IonChip,
    IonCol,
    IonContent,
    IonDatetime,
    IonFab,
    IonFabButton,
    IonFabList,
    IonFooter,
    IonGrid,
    IonHeader,
    IonIcon,
    IonImg,
    IonInfiniteScroll,
    IonInfiniteScrollContent,
    IonInput,
    IonItem,
    IonItemDivider,
    IonItemGroup,
    IonItemOption,
    IonItemOptions,
    IonItemSliding,
    IonLabel,
    IonList,
    IonListHeader,
    IonMenu,
    IonMenuButton,
    IonMenuToggle,
    IonNav,
    IonNavPop,
    IonNavPush,
    IonNavSetRoot,
    IonNote,
    IonProgressBar,
    IonRadio,
    IonRadioGroup,
    IonRange,
    IonRefresher,
    IonRefresherContent,
    IonReorder,
    IonReorderGroup,
    IonRippleEffect,
    IonRow,
    IonSearchbar,
    IonSegment,
    IonSegmentButton,
    IonSelect,
    IonSelectOption,
    IonSkeletonText,
    IonSlide,
    IonSlides,
    IonSpinner,
    IonSplitPane,
    IonTabBar,
    IonTabButton,
    IonText,
    IonTextarea,
    IonThumbnail,
    IonToggle,
    IonToolbar,
    IonTitle,
    IonTabs,
    // ngModel accessors
    BooleanValueAccessor,
    NumericValueAccessor,
    RadioValueAccessor,
    SelectValueAccessor,
    TextValueAccessor,
    // navigation
    IonRouterOutlet,
    IonBackButtonDelegate,
    NavDelegate,
    RouterLinkDelegate,
    // virtual scroll
    VirtualFooter,
    VirtualHeader,
    VirtualItem,
    IonVirtualScroll
];
var IonicModule = /** @class */ (function () {
    function IonicModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    IonicModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: IonicModule,
            providers: [
                {
                    provide: ConfigToken,
                    useValue: config
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: appInitialize,
                    multi: true,
                    deps: [
                        ConfigToken
                    ]
                }
            ]
        };
    };
    IonicModule.decorators = [
        { type: NgModule, args: [{
                    declarations: DECLARATIONS,
                    exports: DECLARATIONS,
                    providers: [AngularDelegate, ModalController, PopoverController],
                    imports: [CommonModule]
                },] },
    ];
    return IonicModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IonicModule, BooleanValueAccessor, BooleanValueAccessor as db, NumericValueAccessor, NumericValueAccessor as dd, RadioValueAccessor, RadioValueAccessor as de, SelectValueAccessor, SelectValueAccessor as df, TextValueAccessor, TextValueAccessor as dg, IonTabs, IonTabs as cv, IonBackButtonDelegate, IonBackButtonDelegate as dh, NavDelegate, NavDelegate as di, IonRouterOutlet, IonRouterOutlet as cw, RouterLinkDelegate, RouterLinkDelegate as dk, NavParams, IonVirtualScroll, IonVirtualScroll as dp, VirtualItem, VirtualItem as do, VirtualHeader, VirtualHeader as dn, VirtualFooter, VirtualFooter as dl, IonApp, IonApp as a, IonAvatar, IonAvatar as b, IonBackButton, IonBackButton as c, IonBackdrop, IonBackdrop as d, IonBadge, IonBadge as e, IonButton, IonButton as f, IonButtons, IonButtons as g, IonCard, IonCard as h, IonCardContent, IonCardContent as i, IonCardHeader, IonCardHeader as j, IonCardSubtitle, IonCardSubtitle as k, IonCardTitle, IonCardTitle as l, IonCheckbox, IonCheckbox as m, IonChip, IonChip as n, IonCol, IonCol as o, IonContent, IonContent as p, IonDatetime, IonDatetime as q, IonFab, IonFab as r, IonFabButton, IonFabButton as s, IonFabList, IonFabList as t, IonFooter, IonFooter as u, IonGrid, IonGrid as v, IonHeader, IonHeader as w, IonIcon, IonIcon as x, IonImg, IonImg as y, IonInfiniteScroll, IonInfiniteScroll as z, IonInfiniteScrollContent, IonInfiniteScrollContent as ba, IonInput, IonInput as bb, IonItem, IonItem as bc, IonItemDivider, IonItemDivider as bd, IonItemGroup, IonItemGroup as be, IonItemOption, IonItemOption as bf, IonItemOptions, IonItemOptions as bg, IonItemSliding, IonItemSliding as bh, IonLabel, IonLabel as bi, IonList, IonList as bj, IonListHeader, IonListHeader as bk, IonMenu, IonMenu as bl, IonMenuButton, IonMenuButton as bm, IonMenuToggle, IonMenuToggle as bn, IonNav, IonNav as bo, IonNavPop, IonNavPop as bp, IonNavPush, IonNavPush as bq, IonNavSetRoot, IonNavSetRoot as br, IonNote, IonNote as bs, IonProgressBar, IonProgressBar as bt, IonRadio, IonRadio as bu, IonRadioGroup, IonRadioGroup as bv, IonRange, IonRange as bw, IonRefresher, IonRefresher as bx, IonRefresherContent, IonRefresherContent as by, IonReorder, IonReorder as bz, IonReorderGroup, IonReorderGroup as ca, IonRippleEffect, IonRippleEffect as cb, IonRow, IonRow as cc, IonSearchbar, IonSearchbar as cd, IonSegment, IonSegment as ce, IonSegmentButton, IonSegmentButton as cf, IonSelect, IonSelect as cg, IonSelectOption, IonSelectOption as ch, IonSkeletonText, IonSkeletonText as ci, IonSlide, IonSlide as cj, IonSlides, IonSlides as ck, IonSpinner, IonSpinner as cl, IonSplitPane, IonSplitPane as cm, IonTabBar, IonTabBar as cn, IonTabButton, IonTabButton as co, IonText, IonText as cp, IonTextarea, IonTextarea as cq, IonThumbnail, IonThumbnail as cr, IonTitle, IonTitle as cs, IonToggle, IonToggle as ct, IonToolbar, IonToolbar as cu, AngularDelegate, AngularDelegate as dj, ActionSheetController, AlertController, Events, LoadingController, MenuController, PickerController, ModalController, ModalController as dq, Platform, Platform as da, PopoverController, PopoverController as ds, ToastController, NavController, NavController as cz, DomController, Config, Config as cx, IonicRouteStrategy, appInitialize as dt, ValueAccessor as dc, ConfigToken as cy, OverlayBaseController as dr };
