{"version":3,"file":"document.js","sourceRoot":"","sources":["../../../../src/firestore/document/document.ts"],"names":[],"mappings":"AAAA,OAAO,EAAc,IAAI,EAAE,MAAM,MAAM,CAAC;AAExC,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;AAErC,OAAO,EAAoB,cAAc,EAAE,MAAM,cAAc,CAAC;AAChE,OAAO,EAAE,0BAA0B,EAAE,MAAM,0BAA0B,CAAC;AAEtE,OAAO,EAAE,SAAS,EAAE,MAAM,eAAe,CAAC;AAwB1C;IAOE,kCAAmB,GAAsB,EAAU,GAAqB;QAArD,QAAG,GAAH,GAAG,CAAmB;QAAU,QAAG,GAAH,GAAG,CAAkB;IAAI,CAAC;IAO7E,sCAAG,GAAH,UAAI,IAAO,EAAE,OAAoB;QAC/B,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACrC,CAAC;IAMD,yCAAM,GAAN,UAAO,IAAgB;QACrB,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;IAKD,yCAAM,GAAN;QACE,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;IAC3B,CAAC;IAQD,6CAAU,GAAV,UAA2B,IAAY,EAAE,OAAiB;QACxD,IAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAA,2CAAuD,EAArD,YAAG,EAAE,gBAAgD,CAAC;QAC9D,OAAO,IAAI,0BAA0B,CAAI,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IACjE,CAAC;IAKD,kDAAe,GAAf;QACE,IAAM,WAAW,GAAG,UAAU,CAAI,IAAI,CAAC,GAAG,CAAC,CAAC;QAC5C,IAAM,oBAAoB,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAC/E,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,sBAAsB,CAAC,oBAAoB,CAAC,CAAC;IACzE,CAAC;IAKD,+CAAY,GAAZ;QACE,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC,IAAI,CAChC,GAAG,CAAC,UAAA,MAAM;YACR,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QAC/B,CAAC,CAAC,CACH,CAAC;IACJ,CAAC;IAMD,sCAAG,GAAH,UAAI,OAA8B;QAChC,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CACrC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CACnC,CAAC;IACJ,CAAC;IACH,+BAAC;AAAD,CAAC,AA1ED,IA0EC","sourcesContent":["import { Observable, from } from 'rxjs';\nimport { DocumentReference, SetOptions, DocumentData, QueryFn, Action, DocumentSnapshot } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map } from 'rxjs/operators';\n\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport { firestore } from 'firebase/app';\nimport { runInZone } from '@angular/fire';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T=DocumentData> {\n\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param ref\n   */\n  constructor(public ref: DocumentReference, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   * @param data\n   * @param options\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   * @param data\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   * @param path\n   * @param queryFn\n   */\n  collection<R=DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path);\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<R>(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const fromDocRef$ = fromDocRef<T>(this.ref);\n    const scheduledFromDocRef$ = this.afs.scheduler.runOutsideAngular(fromDocRef$);\n    return this.afs.scheduler.keepUnstableUntilFirst(scheduledFromDocRef$);\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   */\n  valueChanges(): Observable<T|undefined> {\n    return this.snapshotChanges().pipe(\n      map(action => {\n        return action.payload.data();\n      })\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      runInZone(this.afs.scheduler.zone)\n    );\n  }\n}\n"]}